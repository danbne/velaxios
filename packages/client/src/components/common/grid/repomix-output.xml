This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
ag-grid-theme.css
BaseGrid.tsx
components/ErrorDetails.tsx
components/ErrorDialog.tsx
components/GridToolbar.tsx
components/GridToolbarButton.tsx
GridConfig.tsx
hooks/README.md
hooks/useApiClient.ts
hooks/useDataFetcher.ts
hooks/useErrorHandler.ts
hooks/useGridState.ts
hooks/useOptimizedRowManagement.ts
hooks/useUnsavedChangesWarning.ts
layouts/index.ts
layouts/LayoutContext.tsx
layouts/LayoutStatusPanel.tsx
layouts/LayoutsToolPanel.tsx
layouts/types.ts
layouts/useLayoutManager.ts
README.md
utils/gridComponentRegistration.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="ag-grid-theme.css">
/**
 * AG Grid Theme CSS
 * 
 * This file contains the custom theme styling for AG Grid components.
 * It defines CSS custom properties (variables) for consistent theming
 * and provides styling for grid containers, items, buttons, and interactive elements.
 */

:root {
	--primary: #1caaa6; /* Teal, ideal for buttons or headers */
	--secondary: #15294e; /* Deep navy, great for backgrounds or text */
	--accent: #04d9d2; /* Bright cyan, perfect for highlights or calls-to-action */
	--background: #9dbcf5; /* Light blue, soft for page backgrounds */
	--highlight: #5ebdba; /* Muted teal, for secondary elements or hover states */
	--text-dark: #1c1c1c; /* Dark gray from document, for readable text */
	--text-light: #ffffff; /* White, for text on dark backgrounds */
}

/* Grid Container */
/* Main container styling for grid components */
.as-grid {
	background-color: var(--background);
	color: var(--text-dark);
	font-family: Arial, sans-serif;
}

/* Grid Items */
/* Individual grid item styling with hover effects */
.as-grid__item {
	background-color: var(--secondary);
	color: var(--text-light);
	border: 1px solid var(--highlight);
	padding: 1rem;
	transition: all 0.3s ease;
}

/* Hover State for Grid Items */
/* Enhanced visual feedback when hovering over grid items */
.as-grid__item:hover {
	background-color: var(--highlight);
	border-color: var(--accent);
	transform: translateY(-2px);
}

/* Buttons within Grid */
/* Styling for buttons used within grid components */
.as-grid__button {
	background-color: var(--primary);
	color: var(--text-light);
	border: none;
	padding: 0.5rem 1rem;
	cursor: pointer;
	transition: background-color 0.3s ease;
}

.as-grid__button:hover {
	background-color: var(--accent);
}

/* Headers within Grid */
.as-grid__header {
	background-color: var(--secondary);
	color: var(--text-light);
	padding: 1rem;
	border-bottom: 2px solid var(--primary);
}

/* Active State for Interactive Elements */
.as-grid__item--active {
	background-color: var(--accent);
	color: var(--text-dark);
	border-color: var(--primary);
}

/* Row and cell styles for change tracking */
.ag-row-new {
	background-color: #e8f5e8 !important;
	border-left: 3px solid #4caf50 !important;
}
.ag-row-new .ag-cell {
	background-color: #e8f5e8 !important;
}
.ag-row-dirty {
	background-color: #fff3e0 !important;
	border-left: 3px solid #ff9800 !important;
}
.ag-row-dirty .ag-cell {
	background-color: #fff3e0 !important;
}
.ag-row-deleted {
	background-color: #ffebee !important;
	border-left: 3px solid #f44336 !important;
	opacity: 0.6;
}
.ag-row-deleted .ag-cell {
	background-color: #ffebee !important;
}
.ag-row-failed {
	background-color: #ffebee !important;
}
.ag-row-failed .ag-cell {
	background-color: #ffebee !important;
}
.ag-cell-new {
	background-color: #e8f5e8 !important;
	border-left: 2px solid #4caf50 !important;
}
.ag-cell-dirty {
	background-color: #fff3e0 !important;
	border-left: 2px solid #ff9800 !important;
}
.ag-cell-deleted {
	background-color: #ffebee !important;
	border-left: 2px solid #f44336 !important;
	opacity: 0.6;
}
.ag-cell-failed {
	background-color: #ffebee !important;
	border-left: 2px solid #f44336 !important;
}

/* Responsive Grid Layout */
/* Mobile-specific styling for grid components */
@media (max-width: 768px) {
	.as-grid {
		background-color: var(--background);
	}

	.as-grid__item {
		border: 1px solid var(--highlight);
	}
}
</file>

<file path="BaseGrid.tsx">
"use client";

// React Grid Logic
import { useMemo, useCallback } from "react";

import type { ColDef } from "ag-grid-enterprise";
import {
	ClientSideRowModelModule,
	ValidationModule,
	ModuleRegistry,
	CellSelectionModule,
	ClipboardModule,
	ColumnMenuModule,
	ContextMenuModule,
	UndoRedoEditModule,
} from "ag-grid-enterprise";

// Core CSS
import "../grid/ag-grid-theme.css";
import "../../../styles/grid-styles.css";

// Modular components and hooks
import GridToolbar from "./components/GridToolbar";
import ErrorDialog from "./components/ErrorDialog";
import { AgGridReact } from "ag-grid-react";
import { useGridState } from "./hooks/useGridState";
import { useErrorHandler } from "./hooks/useErrorHandler";
import { useDataFetcher } from "./hooks/useDataFetcher";
import { useOptimizedRowManagement } from "./hooks/useOptimizedRowManagement";
import { useLayoutManager } from "./layouts";
import { createGridConfiguration } from "./GridConfig";
import { useUnsavedChangesWarning } from "./hooks/useUnsavedChangesWarning";
import {
	registerGridComponents,
	getGridComponents,
} from "./utils/gridComponentRegistration";

// Register AG Grid modules for enterprise features
ModuleRegistry.registerModules([
	ClientSideRowModelModule,
	ClipboardModule,
	ColumnMenuModule,
	ContextMenuModule,
	CellSelectionModule,
	UndoRedoEditModule,
	...(process.env.NODE_ENV !== "production" ? [ValidationModule] : []),
]);

// Register custom components with AG Grid
registerGridComponents();

/**
 * Props interface for the BaseGrid component
 *
 * @template T - The type of data objects displayed in the grid
 */
interface BaseGridProps<T> {
	/** Unique identifier for the grid instance, used for state persistence */
	gridId: string;
	/** API endpoint for data operations (fetch, insert, update, delete) */
	endpoint?: string;
	/** Column definitions that specify how each column should be displayed and behave */
	colDefs: ColDef<T>[];
	/** Default column configuration applied to all columns unless overridden */
	defaultColDef?: Partial<ColDef<T>>;

	/** Whether to show the sidebar with columns, filters, and layouts panels */
	sideBarEnabled?: boolean;
	/** Field name used as the primary key for row identification */
	primaryKey: string;
}

/**
 * BaseGrid - Main grid component with comprehensive functionality
 *
 * This component provides a complete data grid solution with the following features:
 *
 * **Core Features:**
 * - Data fetching and display
 * - Draft row management for unsaved changes
 * - Layout management with user-specific saved layouts
 * - Error handling with user-friendly dialogs
 * - Grid state persistence
 *
 * **Advanced Features:**
 * - Multi-row selection
 * - Cell editing with real-time updates
 * - Custom toolbar with CRUD operations
 * - Sidebar with columns, filters, and layouts panels
 * - Status bar with row counts and layout information
 *
 * **Architecture:**
 * The component is organized into focused modules using custom hooks:
 * - useLayoutManager: Handles layout operations
 * - createGridConfiguration: Manages grid UI configuration
 * - useRowManagement: Handles row operations and grid events
 * - useGridState: Manages grid state and data persistence
 *
 * @template T - The type of data objects displayed in the grid
 * @param props - Configuration props for the grid
 * @returns JSX element representing the complete grid interface
 */
const BaseGrid = <T,>({
	gridId,
	endpoint, // Single endpoint for both fetch and insert operations
	colDefs,
	defaultColDef,

	sideBarEnabled = true,
	primaryKey,
}: BaseGridProps<T>) => {
	// ===== CORE HOOKS =====
	// Error handling with user-friendly dialogs and error recovery
	const { errorPopup, showDialog, flashRed, showError, clearError } =
		useErrorHandler();

	// Data fetching with caching and error handling - only when endpoint is provided
	const { createFetchData } = useDataFetcher<T>(endpoint);

	// Memoize fetchData so it doesn't change on every render
	const fetchData = useMemo(() => {
		if (!endpoint) {
			// Return empty data function if no endpoint
			return async (): Promise<T[]> => [];
		}
		return createFetchData();
	}, [endpoint, createFetchData]);

	// ===== GRID STATE MANAGEMENT =====
	// Manages grid state, loading states, and data persistence
	const {
		rowData,
		setRowData,
		setIsLoading,
		gridApi,
		savedState,
		shouldShowGrid,
		onGridReady,
	} = useGridState<T>({ gridId, fetchData });

	// ===== ROW MANAGEMENT =====
	// Handles all row operations, change tracking, and grid events

	// Memoize the onSaveSuccess callback to prevent infinite re-renders
	const onSaveSuccess = useMemo(
		() => (savedData: any) => {
			// Extract the actual data from the server response
			// The server returns { message, results, summary } structure
			const actualData = savedData.results || savedData;

			// Update the main row data with the saved results
			setRowData((prevData) => {
				// Remove deleted rows (with null check)
				const withoutDeleted = prevData.filter(
					(row) =>
						!(actualData.deleted || []).includes((row as any)[primaryKey])
				);

				// Remove temp rows (they will be replaced with saved data)
				const withoutTempRows = withoutDeleted.filter(
					(row) => !(row as any).__isNewRow
				);

				// Remove rows that were marked as deleted locally
				const withoutLocalDeleted = withoutTempRows.filter(
					(row) => !(row as any).__isDeleted
				);

				// Update existing rows with server data
				const updated = withoutLocalDeleted.map((row) => {
					const updatedRow = (actualData.updated || []).find(
						(updated: any) =>
							(updated as any)[primaryKey] === (row as any)[primaryKey]
					);
					return updatedRow || row;
				});

				// Add new rows with server-assigned primary keys
				// If actualData.added is empty but we had temp rows, keep the temp rows
				// but mark them as no longer new
				const addedRows = actualData.added || [];
				const tempRows = prevData.filter((row) => (row as any).__isNewRow);

				let finalRows = [...updated];

				if (addedRows.length > 0) {
					// Server returned saved data, use it
					finalRows = [...finalRows, ...addedRows];
				} else if (tempRows.length > 0) {
					// Server didn't return added data, but we had temp rows
					// Keep them but mark as no longer new
					const nonNewTempRows = tempRows.map((row) => ({
						...row,
						__isNewRow: false,
						__isDirty: false,
					}));
					finalRows = [...finalRows, ...nonNewTempRows];
				}

				return finalRows;
			});
		},
		[primaryKey, setRowData]
	);

	const {
		hasUnsavedChanges,
		addNewRow,
		saveChanges,
		clearChanges,
		getRowId,
		getContextMenuItems,
		handleCellValueChanged,
		handleCellEditingStopped,
		deleteSelectedRows,
		duplicateSelectedRow,
		getRowClass,
		getCellClass,
		undo,
		redo,
		canUndo,
		canRedo,
	} = useOptimizedRowManagement({
		endpoint,
		showError,
		primaryKey,
		onSaveSuccess,
		rowData,
		setRowData,
		colDefs,
		gridApi,
	});

	// ===== LAYOUT MANAGEMENT =====
	// Handles user-specific layout operations (save, load, change)
	const { handleLayoutChange, handleLayoutSave } = useLayoutManager({
		gridId,
		gridApi,
	});

	// ===== GRID ACTIONS =====
	// Handles toolbar actions (add, delete, duplicate, refresh)
	const handleAddRow = useCallback(() => {
		const newRow = addNewRow({});
		setRowData((prev) => [...prev, newRow]);
	}, [addNewRow, setRowData]);

	const handleAddMultipleRows = useCallback(() => {
		// For now, just add one row. Could be enhanced to add multiple
		const newRow = addNewRow({});
		setRowData((prev) => [...prev, newRow]);
	}, [addNewRow, setRowData]);

	const handleDeleteRows = useCallback(() => {
		deleteSelectedRows(gridApi);
	}, [deleteSelectedRows, gridApi]);

	const handleDuplicateRow = useCallback(() => {
		duplicateSelectedRow(gridApi);
	}, [duplicateSelectedRow, gridApi]);

	const handleRefresh = useCallback(async () => {
		setIsLoading(true);
		try {
			const freshData = await fetchData();
			setRowData(freshData);
			clearChanges();
		} catch (error) {
			showError(error);
		} finally {
			setIsLoading(false);
		}
	}, [fetchData, setRowData, clearChanges, showError, setIsLoading]);

	const handleSave = useCallback(async () => {
		await saveChanges();
	}, [saveChanges]);

	// ===== GRID CONFIGURATION =====
	// Creates grid UI components (status bar, sidebar, row selection, column defaults)
	// Memoize the grid config to stabilize references and prevent unnecessary re-renders
	const gridConfig = useMemo(
		() =>
			createGridConfiguration({
				sideBarEnabled,
				gridId,
				handleLayoutChange,
				handleLayoutSave,
				defaultColDef,
			}),
		[
			sideBarEnabled,
			gridId,
			handleLayoutChange,
			handleLayoutSave,
			defaultColDef,
		]
	);

	// ===== UNSAVED CHANGES WARNING =====
	// Warns users about unsaved changes when navigating away or refreshing

	// Memoize the onConfirmNavigation callback to prevent infinite re-renders
	const onConfirmNavigation = useCallback(() => {
		// Clear pending changes and refresh data
		clearChanges();
		handleRefresh();
	}, [clearChanges, handleRefresh]);

	const { confirmRefresh } = useUnsavedChangesWarning({
		hasUnsavedChanges,
		onConfirmNavigation,
	});

	// Wrapper for refresh that checks for unsaved changes
	const handleRefreshWithWarning = useCallback(() => {
		if (confirmRefresh()) {
			handleRefresh();
		}
	}, [confirmRefresh, handleRefresh]);

	// ===== RENDER =====
	return (
		<>
			{/* Error dialog for displaying user-friendly error messages */}
			<ErrorDialog
				error={errorPopup}
				showDialog={showDialog}
				flashRed={flashRed}
				onClose={clearError}
			/>

			<div style={{ width: "100%", height: "100%" }}>
				{/* Loading state while grid is initializing */}
				{!shouldShowGrid ? (
					<div style={{ textAlign: "center", padding: "20px" }}>
						<p>Loading data...</p>
					</div>
				) : (
					<>
						{/* Custom toolbar with CRUD operations */}
						<GridToolbar
							onAddRow={handleAddRow}
							onAddMultipleRows={handleAddMultipleRows}
							onDeleteRows={handleDeleteRows}
							onDuplicateRow={handleDuplicateRow}
							onSave={handleSave}
							onRefresh={handleRefreshWithWarning}
							hasUnsavedChanges={hasUnsavedChanges}
							onUndo={undo}
							onRedo={redo}
							canUndo={canUndo}
							canRedo={canRedo}
							gridApi={gridApi}
						/>

						{/* Main AG Grid component with all configurations */}
						<div style={{ height: "calc(100% - 60px)" }}>
							<AgGridReact
								// Row styling rules
								rowClassRules={{
									"ag-row-new": (params: any) => params.data?.__isNewRow,
									"ag-row-dirty": (params: any) => params.data?.__isDirty,
									"ag-row-deleted": (params: any) => params.data?.__isDeleted,
									"ag-row-failed": (params: any) => params.data?.__isFailed,
								}}
								// Grid options
								statusBar={gridConfig.statusBar}
								sideBar={gridConfig.sideBar}
								enableFilterHandlers={true}
								suppressSetFilterByDefault={true}
								// Performance optimizations
								// Event handlers
								onGridReady={onGridReady}
								onCellValueChanged={handleCellValueChanged}
								onCellEditingStopped={handleCellEditingStopped}
								// Data and configuration
								rowData={rowData}
								columnDefs={colDefs}
								defaultColDef={gridConfig.defaultColDefInternal}
								initialState={savedState}
								suppressContextMenu={false}
								rowSelection={gridConfig.rowSelection}
								cellSelection={true}
								getRowId={getRowId}
								getContextMenuItems={getContextMenuItems as any}
								// Row styling
								getRowClass={getRowClass}
								// Custom components
								components={getGridComponents()}
							/>
						</div>
					</>
				)}
			</div>
		</>
	);
};

// Export ColDef type for use in other components
export type { ColDef };
export default BaseGrid;
</file>

<file path="components/ErrorDetails.tsx">
import React, { useState } from "react";
import { componentThemes } from "../../../../styles/theme";

interface ErrorDetailsProps {
	details: Record<string, any>;
}

/**
 * ErrorDetails - Sub-component for displaying error details
 *
 * This component handles the collapsible details section of error dialogs.
 * It provides:
 * - Toggle functionality to show/hide details
 * - Formatted JSON display of error details
 * - Copy to clipboard functionality
 * - Proper styling and accessibility
 *
 * @param details - The error details object to display
 * @returns JSX element representing the error details section
 */
const ErrorDetails: React.FC<ErrorDetailsProps> = ({ details }) => {
	const [isOpen, setIsOpen] = useState(false);

	const handleToggle = () => {
		setIsOpen(!isOpen);
	};

	const handleCopyDetails = async () => {
		try {
			await navigator.clipboard.writeText(JSON.stringify(details, null, 2));
		} catch (error) {
			console.error("Failed to copy details:", error);
		}
	};

	const formattedDetails = JSON.stringify(details, null, 2);

	return (
		<div style={{ marginTop: "12px" }}>
			<button
				style={componentThemes.errorDialog.detailsButton}
				onClick={handleToggle}
				aria-expanded={isOpen}
				aria-controls="error-details"
			>
				{isOpen ? "Hide details" : "Show details"}
			</button>

			{isOpen && (
				<div
					id="error-details"
					style={componentThemes.errorDialog.detailsContainer}
					role="region"
					aria-label="Error details"
				>
					<pre style={{ margin: 0, whiteSpace: "pre-wrap" }}>
						{formattedDetails}
					</pre>
					<button
						style={componentThemes.errorDialog.copyButton}
						onClick={handleCopyDetails}
						title="Copy error details to clipboard"
					>
						Copy details
					</button>
				</div>
			)}
		</div>
	);
};

export default ErrorDetails;
</file>

<file path="components/ErrorDialog.tsx">
import React from "react";
import { componentThemes, mergeStyles } from "../../../../styles/theme";
import Dialog from "../../Dialog";
import ErrorDetails from "./ErrorDetails";
import Button from "../../Button";

interface ErrorDialogProps {
	error: string | { message: string; details?: Record<string, any> } | null;
	showDialog: boolean;
	flashRed: boolean;
	onClose: () => void;
}

/**
 * ErrorDialog - Simplified error dialog component
 *
 * This component displays user-friendly error messages with optional details.
 * It uses the centralized theme system and Dialog component for consistent styling
 * and includes accessibility features for better user experience.
 *
 * Features:
 * - Clean, consistent styling using theme system
 * - Collapsible error details via ErrorDetails component
 * - Proper accessibility attributes
 * - Flash red animation for critical errors
 * - Responsive design
 * - Reusable Dialog component
 *
 * @param error - Error message string or object with message and optional details
 * @param showDialog - Whether to display the dialog
 * @param flashRed - Whether to flash red background for critical errors
 * @param onClose - Callback function when dialog is closed
 * @returns JSX element representing the error dialog
 */
const ErrorDialog: React.FC<ErrorDialogProps> = ({
	error,
	showDialog,
	flashRed,
	onClose,
}) => {
	if (!showDialog || !error) return null;

	// Extract error message and details
	const errorMessage = typeof error === "string" ? error : error.message;
	const errorDetails = typeof error === "object" ? error.details : undefined;

	// Determine container styles based on flash state
	const containerStyles = flashRed
		? mergeStyles(
				componentThemes.errorDialog.container,
				componentThemes.errorDialog.flashRed
		  )
		: componentThemes.errorDialog.container;

	return (
		<Dialog isOpen={showDialog} onClose={onClose} style={containerStyles}>
			{/* Main error message */}
			<div style={{ color: componentThemes.errorDialog.container.color }}>
				{errorMessage}
			</div>

			{/* Error details section */}
			{errorDetails && <ErrorDetails details={errorDetails} />}

			{/* Close button */}
			<Button
				variant="secondary"
				size="sm"
				onClick={onClose}
				style={componentThemes.errorDialog.closeButton}
			>
				Close
			</Button>
		</Dialog>
	);
};

export default ErrorDialog;
</file>

<file path="components/GridToolbar.tsx">
import React, { memo } from "react";
import GridToolbarButton from "./GridToolbarButton";

/**
 * Props interface for the GridToolbar component
 */
interface GridToolbarProps {
	/** Callback function for adding a single row */
	onAddRow: () => void;
	/** Callback function for adding multiple rows */
	onAddMultipleRows: () => void;
	/** Callback function for deleting selected rows */
	onDeleteRows: () => void;
	/** Callback function for duplicating selected rows */
	onDuplicateRow: () => void;
	/** Callback function for saving changes */
	onSave: () => Promise<any>;
	/** Callback function for refreshing the grid */
	onRefresh: () => void;
	/** Whether there are unsaved changes */
	hasUnsavedChanges?: boolean;
	/** Custom undo function */
	onUndo?: () => void;
	/** Custom redo function */
	onRedo?: () => void;
	/** Whether undo operation is available */
	canUndo?: boolean;
	/** Whether redo operation is available */
	canRedo?: boolean;
	/** AG Grid API instance for native undo/redo operations */
	gridApi?: any;
}

/**
 * GridToolbar - Custom toolbar component for grid operations
 *
 * This component provides a comprehensive toolbar with buttons for:
 * - Custom Undo/Redo operations for row operations
 * - Row management (add, delete, duplicate)
 * - Data operations (save, refresh)
 * - Visual feedback for unsaved changes
 *
 * The toolbar is styled to match the grid theme and provides
 * clear visual feedback for button states and availability.
 *
 * @param props - Configuration and callback functions for toolbar actions
 * @returns JSX element representing the grid toolbar
 */
const GridToolbar: React.FC<GridToolbarProps> = memo(
	({
		onAddRow,
		onAddMultipleRows,
		onDeleteRows,
		onDuplicateRow,
		onSave,
		onRefresh,
		hasUnsavedChanges = false,
		onUndo,
		onRedo,
		canUndo = false,
		canRedo = false,
		gridApi,
	}) => {
		// Removed console.log to prevent endless loop
		const handleSave = async () => {
			try {
				await onSave();
			} catch (error) {
				// Error is already handled by the saveChanges function
				// This just prevents the uncaught exception
				console.error("Save operation failed:", error);
			}
		};

		return (
			<div
				style={{
					display: "flex",
					justifyContent: "space-between",
					alignItems: "center",
					padding: "8px",
					borderBottom: "1px solid #e0e0e0",
					backgroundColor: "#f8f9fa",
				}}
			>
				{/* Status Label */}
				<div
					style={{
						display: "flex",
						alignItems: "center",
						gap: "16px",
						fontSize: "12px",
						color: "#666",
					}}
				>
					{hasUnsavedChanges ? (
						<span>📝 Unsaved changes</span>
					) : (
						<span>✨ No unsaved changes</span>
					)}
				</div>

				{/* Toolbar Buttons */}
				<div style={{ display: "flex", alignItems: "center" }}>
					{/* Custom Undo/Redo buttons */}
					<GridToolbarButton
						icon="↶"
						tooltip="Undo"
						onClick={() => onUndo?.()}
						disabled={!canUndo}
					/>
					<GridToolbarButton
						icon="↷"
						tooltip="Redo"
						onClick={() => onRedo?.()}
						disabled={!canRedo}
					/>

					{/* Separator */}
					<div
						style={{
							width: "1px",
							height: "24px",
							backgroundColor: "#e0e0e0",
							margin: "0 8px",
						}}
					/>

					<GridToolbarButton icon="➕" tooltip="Add Row" onClick={onAddRow} />

					<GridToolbarButton
						icon="🗑️"
						tooltip="Delete Selected Rows"
						onClick={onDeleteRows}
					/>
					<GridToolbarButton
						icon="📄"
						tooltip="Duplicate Row"
						onClick={onDuplicateRow}
					/>
					<GridToolbarButton
						icon=" 💾"
						tooltip={hasUnsavedChanges ? "Save Changes" : "Save"}
						onClick={handleSave}
						disabled={!hasUnsavedChanges}
						isSaveButton={true}
						hasUnsavedChanges={hasUnsavedChanges}
					/>
					<GridToolbarButton icon="🔄" tooltip="Refresh" onClick={onRefresh} />
				</div>
			</div>
		);
	}
);

export default GridToolbar;
</file>

<file path="components/GridToolbarButton.tsx">
import React from "react";

/**
 * Props interface for the GridToolbarButton component
 */
interface ToolbarButtonProps {
	/** Unicode icon or emoji to display on the button */
	icon: string;
	/** Tooltip text shown on hover */
	tooltip: string;
	/** Click handler function */
	onClick?: () => void;
	/** Whether the button is disabled */
	disabled?: boolean;
	/** Whether this is the save button (affects styling) */
	isSaveButton?: boolean;
	/** Whether there are unsaved changes (for save button styling) */
	hasUnsavedChanges?: boolean;
}

/**
 * GridToolbarButton - Individual button component for grid toolbar
 *
 * This component renders a single toolbar button with:
 * - Unicode icon display
 * - Tooltip on hover
 * - Disabled state styling
 * - Special styling for save button with unsaved changes
 * - Consistent styling with the grid theme
 *
 * The button adapts its appearance based on its type and state,
 * providing clear visual feedback to users.
 *
 * @param props - Configuration for the button appearance and behavior
 * @returns JSX element representing a toolbar button
 */
const GridToolbarButton: React.FC<ToolbarButtonProps> = ({
	icon,
	tooltip,
	onClick,
	disabled = false,
	isSaveButton = false,
	hasUnsavedChanges = false,
}) => {
	// Determine button color based on type and state
	let buttonColor = "#333";
	if (disabled) {
		buttonColor = "#ccc";
	} else if (isSaveButton && hasUnsavedChanges) {
		buttonColor = "#007bff"; // Blue for save button with changes
	}

	return (
		<button
			className="toolbar-button"
			onClick={onClick}
			disabled={disabled}
			title={tooltip}
			style={{
				background: "none",
				border: "none",
				padding: "8px",
				margin: "0 2px",
				cursor: disabled ? "not-allowed" : "pointer",
				borderRadius: "4px",
				color: buttonColor,
				fontSize: "16px",
				transition: "color 0.2s ease",
			}}
		>
			{icon}
		</button>
	);
};

export default GridToolbarButton;
</file>

<file path="GridConfig.tsx">
import type { ColDef } from "./BaseGrid";

/**
 * Creates the status bar configuration for the grid
 *
 * The status bar displays various information panels at the bottom of the grid:
 * - Total row count: Shows the total number of rows in the dataset
 * - Filtered row count: Shows the number of rows after applying filters
 * - Selected row count: Shows the number of currently selected rows
 * - Aggregation component: Displays aggregated values for selected cells
 * - Layout status panel: Custom panel showing current layout and save button
 *
 * @param gridId - Unique identifier for the grid instance
 * @param onLayoutSave - Callback function for saving the current layout
 * @returns Status bar configuration object for AG Grid
 */
export const createStatusBar = (
	gridId?: string,
	onLayoutSave?: (layoutData: any) => void
) => {
	return {
		statusPanels: [
			//{ statusPanel: "agTotalAndFilteredRowCountComponent" },
			{ statusPanel: "agTotalRowCountComponent" },
			{ statusPanel: "agFilteredRowCountComponent" },
			{ statusPanel: "agSelectedRowCountComponent" },
			{
				statusPanel: "agAggregationComponent",
				statusPanelParams: {
					//aggFuncs: ["avg"],
				},
			},
			{
				statusPanel: "agLayoutStatusPanel",
				align: "left",
				statusPanelParams: {
					gridId,
					onLayoutSave,
				},
			},
		],
	};
};

/**
 * Creates the sidebar configuration for the grid
 *
 * The sidebar contains tool panels that provide additional functionality:
 * - Columns panel: Allows users to show/hide columns and reorder them
 * - Filters panel: Provides advanced filtering capabilities
 * - Layouts panel: Custom panel for managing user-specific grid layouts
 *
 * Each panel has specific width constraints and functionality.
 * The sidebar is positioned on the right side of the grid by default.
 *
 * @param sideBarEnabled - Whether the sidebar should be displayed
 * @param gridId - Unique identifier for the grid instance
 * @param onLayoutChange - Callback function for when layout changes
 * @param onLayoutSave - Callback function for saving layouts
 * @returns Sidebar configuration object for AG Grid, or null if disabled
 */
export const createSideBar = (
	sideBarEnabled: boolean,
	gridId?: string,
	onLayoutChange?: (layoutData: any) => void,
	onLayoutSave?: (layoutData: any) => void
) => {
	if (sideBarEnabled) {
		return {
			toolPanels: [
				{
					id: "columns",
					labelDefault: "Columns",
					labelKey: "columns",
					iconKey: "columns",
					toolPanel: "agColumnsToolPanel",
					minWidth: 225,
					maxWidth: 225,
					width: 225,
				},
				{
					id: "filters",
					labelDefault: "Filters",
					labelKey: "filters",
					iconKey: "filter",
					toolPanel: "agNewFiltersToolPanel",
					minWidth: 180,
					maxWidth: 400,
					width: 250,
				},
				{
					id: "layouts",
					labelDefault: "Layouts",
					labelKey: "layouts",
					iconKey: "menu",
					toolPanel: "agLayoutsToolPanel",
					minWidth: 250,
					maxWidth: 300,
					width: 250,
					toolPanelParams: {
						gridId,
						onLayoutChange,
						onLayoutSave,
					},
				},
			],
			position: "right" as const,
			defaultToolPanel: "columns",
		};
	}
	return null;
};

/**
 * Creates the row selection configuration for the grid
 *
 * Currently configured for multi-row selection mode, allowing users
 * to select multiple rows simultaneously using Ctrl/Cmd+click or
 * Shift+click for range selection.
 *
 * @returns Row selection configuration object for AG Grid
 */
export const createRowSelection = () => {
	return {
		mode: "multiRow" as const,
	};
};

/**
 * Creates default column definitions for the grid
 *
 * This function merges the provided defaultColDef with system defaults
 * to ensure consistent behavior across all columns. The default configuration
 * includes:
 * - Filtering enabled on all columns
 * - Floating filters enabled for quick filtering
 * - Cell editing enabled for copy-paste operations
 *
 * @template T - The type of data objects displayed in the grid
 * @param defaultColDef - Optional custom default column configuration
 * @returns Merged default column definition object
 */
export const createDefaultColDef = <T,>(defaultColDef?: Partial<ColDef<T>>) => {
	return {
		filter: true, // default enabling filtering
		floatingFilter: true, // default enabling floating filters
		editable: true, // enable editing for copy-paste
		...defaultColDef,
	};
};

/**
 * Creates a complete grid configuration object
 *
 * This function consolidates all grid configuration options into a single
 * object, replacing the need for the useGridConfiguration hook. It handles:
 * - Status bar configuration with layout information
 * - Sidebar configuration with tool panels
 * - Row selection behavior
 * - Default column definitions
 *
 * @param sideBarEnabled - Whether the sidebar should be displayed
 * @param gridId - Unique identifier for the grid instance
 * @param handleLayoutChange - Function to handle layout changes
 * @param handleLayoutSave - Function to handle layout saves
 * @param defaultColDef - Default column configuration
 * @returns Complete grid configuration object
 */
export const createGridConfiguration = <T,>({
	sideBarEnabled,
	gridId,
	handleLayoutChange,
	handleLayoutSave,
	defaultColDef,
}: {
	sideBarEnabled: boolean;
	gridId: string;
	handleLayoutChange: (layoutData: any) => void;
	handleLayoutSave: (layoutData: any) => void;
	defaultColDef?: Partial<ColDef<T>>;
}) => {
	return {
		statusBar: createStatusBar(gridId, handleLayoutSave),
		sideBar: createSideBar(
			sideBarEnabled,
			gridId,
			handleLayoutChange,
			handleLayoutSave
		),
		rowSelection: createRowSelection(),
		defaultColDefInternal: createDefaultColDef(defaultColDef),
	};
};
</file>

<file path="hooks/README.md">
# Shared API Client Hooks

This directory contains shared API client hooks that provide consistent patterns for API calls across the application, with React Query integration for caching, error handling, and authentication.

## Overview

The shared API client hooks consolidate common API patterns and provide:

- **React Query Integration**: Automatic caching, background updates, and retry logic
- **Consistent Error Handling**: Normalized error messages and authentication redirects
- **Type Safety**: Full TypeScript support with generic types
- **Optimistic Updates**: Support for optimistic UI updates with rollback
- **Query Invalidation**: Automatic cache invalidation for related queries

## Available Hooks

### `useApiGet<T>`

For GET requests with caching and automatic retries.

```typescript
const { data, error, isLoading, refetch } = useApiGet<MyDataType>(
	["my-data", id], // Query key
	"/api/my-endpoint", // Endpoint
	{
		enabled: true, // Optional: control when query runs
		staleTime: 5 * 60 * 1000, // Optional: how long data stays fresh
		retry: 3, // Optional: retry attempts
	}
);
```

### `useApiPost<T>`

For POST mutations with optimistic updates and cache invalidation.

```typescript
const createMutation = useApiPost<MyResponseType>({
	invalidateQueries: ["my-data"], // Queries to invalidate on success
	onSuccess: (data) => {
		// Handle success
	},
	onError: (error) => {
		// Handle error
	},
});

// Usage
await createMutation.mutateAsync({
	endpoint: "/api/create",
	data: { name: "New Item" },
});
```

### `useApiPut<T>`

For PUT mutations with optimistic updates.

```typescript
const updateMutation = useApiPut<MyResponseType>({
	invalidateQueries: ["my-data"],
});

await updateMutation.mutateAsync({
	endpoint: "/api/update/123",
	data: { name: "Updated Item" },
});
```

### `useApiDelete<T>`

For DELETE mutations with cache invalidation.

```typescript
const deleteMutation = useApiDelete<MyResponseType>({
	invalidateQueries: ["my-data"],
});

await deleteMutation.mutateAsync({
	endpoint: "/api/delete/123",
});
```

### `useApiPatch<T>`

For PATCH mutations with optimistic updates.

```typescript
const patchMutation = useApiPatch<MyResponseType>({
	invalidateQueries: ["my-data"],
});

await patchMutation.mutateAsync({
	endpoint: "/api/patch/123",
	data: { status: "active" },
});
```

## Migration Guide

### From Direct API Calls

**Before:**

```typescript
const [data, setData] = useState([]);
const [loading, setLoading] = useState(false);

const fetchData = async () => {
	try {
		setLoading(true);
		const response = await apiGet("/api/data");
		setData(response.data);
	} catch (error) {
		console.error("Error:", error);
		if (error.response?.status === 401) {
			localStorage.removeItem("token");
			window.location.href = "/login";
		}
	} finally {
		setLoading(false);
	}
};
```

**After:**

```typescript
const { data, error, isLoading, refetch } = useApiGet<MyDataType>(
	["data"],
	"/api/data"
);
```

### From Manual State Management

**Before:**

```typescript
const [layouts, setLayouts] = useState([]);
const [isLoading, setIsLoading] = useState(false);

const fetchLayouts = async () => {
	try {
		setIsLoading(true);
		const response = await apiGet("/api/layouts");
		setLayouts(response.gridLayout);
	} catch (error) {
		// Error handling
	} finally {
		setIsLoading(false);
	}
};
```

**After:**

```typescript
const {
	data: layoutsData,
	error,
	isLoading,
} = useApiGet<any>(["layouts", gridId], API_ENDPOINTS.GRID_LAYOUTS(gridId), {
	onSuccess: (data) => {
		// Handle success
	},
	onError: (error) => {
		// Handle error
	},
});

const layouts = layoutsData?.gridLayout || [];
```

## Benefits

1. **Reduced Code Duplication**: ~100 lines of repeated try-catch blocks eliminated
2. **Automatic Caching**: React Query handles caching, background updates, and stale data management
3. **Consistent Error Handling**: Centralized error normalization and authentication redirects
4. **Better UX**: Loading states, error states, and optimistic updates handled automatically
5. **Type Safety**: Full TypeScript support with proper type inference
6. **Performance**: Automatic request deduplication and background refetching

## Configuration

The hooks use default configuration that can be customized:

- **Stale Time**: 5 minutes (data considered fresh)
- **Cache Time**: 10 minutes (how long to keep unused data)
- **Retry**: 3 attempts with exponential backoff
- **Authentication**: Automatic token handling and 401 redirects

## Error Handling

All hooks provide consistent error handling:

- **401 Unauthorized**: Automatic redirect to login page
- **Network Errors**: User-friendly error messages
- **Server Errors**: Appropriate error messages with retry options
- **Normalized Errors**: Consistent error object structure

## Cache Management

The hooks integrate with React Query's cache management:

- **Automatic Invalidation**: Related queries are invalidated on mutations
- **Background Updates**: Data is refreshed in the background
- **Optimistic Updates**: UI updates immediately with rollback on error
- **Query Keys**: Structured query keys for efficient cache management
</file>

<file path="hooks/useApiClient.ts">
import { useCallback, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
	apiGet,
	apiPost,
	apiPut,
	apiDelete,
	apiPatch,
} from "../../../../utils/apiClient";
import { AxiosRequestConfig } from "axios";

// Types for the hook
export interface ApiClientOptions {
	enabled?: boolean;
	staleTime?: number;
	cacheTime?: number;
	retry?: number | boolean;
	retryDelay?: number;
	onSuccess?: (data: any) => void;
	onError?: (error: any) => void;
	onSettled?: (data: any, error: any) => void;
}

export interface MutationOptions extends ApiClientOptions {
	onMutate?: (variables: any) => void;
	onMutateError?: (error: any, variables: any, context: any) => void;
}

export interface ApiClientConfig {
	baseUrl?: string;
	defaultOptions?: ApiClientOptions;
}

/**
 * Enhanced error handler that normalizes errors and handles auth redirects
 */
const handleError = (error: any) => {
	console.error("API Error:", error);

	// Handle authentication errors
	if (error.response?.status === 401) {
		localStorage.removeItem("token");
		window.location.href = "/login";
		return;
	}

	// Normalize error messages
	const errorMessage =
		error.response?.data?.message ||
		error.message ||
		"An unexpected error occurred";

	return {
		message: errorMessage,
		status: error.response?.status,
		details: error.response?.data,
	};
};

/**
 * Shared API client hook that provides:
 * - React Query integration for caching and background updates
 * - Consistent error handling and authentication redirects
 * - Optimistic updates for mutations
 * - Automatic retry logic
 * - Type-safe API calls
 */
export const useApiClient = (config?: ApiClientConfig) => {
	const queryClient = useQueryClient();

	const defaultOptions = useMemo(
		() => ({
			staleTime: 5 * 60 * 1000, // 5 minutes
			cacheTime: 10 * 60 * 1000, // 10 minutes
			retry: 3,
			retryDelay: (attemptIndex: number) =>
				Math.min(1000 * 2 ** attemptIndex, 30000),
			...config?.defaultOptions,
		}),
		[config?.defaultOptions]
	);

	/**
	 * Utility function to invalidate queries
	 */
	const invalidateQueries = useCallback(
		(queryKeys: string[]) => {
			queryKeys.forEach((queryKey) => {
				queryClient.invalidateQueries({ queryKey: [queryKey] });
			});
		},
		[queryClient]
	);

	/**
	 * Utility function to set query data directly
	 */
	const setQueryData = useCallback(
		<T>(queryKey: string, data: T) => {
			queryClient.setQueryData([queryKey], data);
		},
		[queryClient]
	);

	return {
		defaultOptions,
		invalidateQueries,
		setQueryData,
		queryClient,
	};
};

/**
 * GET request with React Query caching
 */
export const useApiGet = <T = any>(
	key: string | string[],
	endpoint: string,
	options?: ApiClientOptions & { requestConfig?: AxiosRequestConfig }
) => {
	const queryKey = Array.isArray(key) ? key : [key];

	return useQuery({
		queryKey,
		queryFn: async (): Promise<T> => {
			try {
				const data = await apiGet<T>(endpoint, options?.requestConfig);
				return data;
			} catch (error) {
				const normalizedError = handleError(error);
				throw normalizedError;
			}
		},
		enabled: options?.enabled ?? true,
		staleTime: options?.staleTime ?? 5 * 60 * 1000,
		gcTime: options?.cacheTime ?? 10 * 60 * 1000,
		retry: options?.retry ?? 3,
		retryDelay:
			options?.retryDelay ??
			((attemptIndex: number) => Math.min(1000 * 2 ** attemptIndex, 30000)),
	});
};

/**
 * POST mutation with optimistic updates
 */
export const useApiPost = <T = any>(
	options?: MutationOptions & {
		invalidateQueries?: string[];
		optimisticUpdate?: (variables: any) => any;
	}
) => {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			endpoint,
			data,
			requestConfig,
		}: {
			endpoint: string;
			data?: any;
			requestConfig?: AxiosRequestConfig;
		}): Promise<T> => {
			try {
				const response = await apiPost<T>(endpoint, data, requestConfig);
				return response;
			} catch (error) {
				const normalizedError = handleError(error);
				throw normalizedError;
			}
		},
		onMutate: options?.onMutate,
		onSuccess: (data, variables) => {
			// Invalidate related queries
			if (options?.invalidateQueries) {
				options.invalidateQueries.forEach((queryKey) => {
					queryClient.invalidateQueries({ queryKey: [queryKey] });
				});
			}
			options?.onSuccess?.(data);
		},
		onError: (error, variables, context) => {
			// Rollback optimistic updates if needed
			if (context) {
				queryClient.setQueryData(
					[options?.invalidateQueries?.[0] || "data"],
					context
				);
			}
			options?.onError?.(error);
		},
		onSettled: options?.onSettled,
	});
};

/**
 * PUT mutation with optimistic updates
 */
export const useApiPut = <T = any>(
	options?: MutationOptions & {
		invalidateQueries?: string[];
		optimisticUpdate?: (variables: any) => any;
	}
) => {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			endpoint,
			data,
			requestConfig,
		}: {
			endpoint: string;
			data?: any;
			requestConfig?: AxiosRequestConfig;
		}): Promise<T> => {
			try {
				const response = await apiPut<T>(endpoint, data, requestConfig);
				return response;
			} catch (error) {
				const normalizedError = handleError(error);
				throw normalizedError;
			}
		},
		onMutate: options?.onMutate,
		onSuccess: (data, variables) => {
			// Invalidate related queries
			if (options?.invalidateQueries) {
				options.invalidateQueries.forEach((queryKey) => {
					queryClient.invalidateQueries({ queryKey: [queryKey] });
				});
			}
			options?.onSuccess?.(data);
		},
		onError: (error, variables, context) => {
			// Rollback optimistic updates if needed
			if (context) {
				queryClient.setQueryData(
					[options?.invalidateQueries?.[0] || "data"],
					context
				);
			}
			options?.onError?.(error);
		},
		onSettled: options?.onSettled,
	});
};

/**
 * DELETE mutation with optimistic updates
 */
export const useApiDelete = <T = any>(
	options?: MutationOptions & {
		invalidateQueries?: string[];
		optimisticUpdate?: (variables: any) => any;
	}
) => {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			endpoint,
			requestConfig,
		}: {
			endpoint: string;
			requestConfig?: AxiosRequestConfig;
		}): Promise<T> => {
			try {
				const response = await apiDelete<T>(endpoint, requestConfig);
				return response;
			} catch (error) {
				const normalizedError = handleError(error);
				throw normalizedError;
			}
		},
		onMutate: options?.onMutate,
		onSuccess: (data, variables) => {
			// Invalidate related queries
			if (options?.invalidateQueries) {
				options.invalidateQueries.forEach((queryKey) => {
					queryClient.invalidateQueries({ queryKey: [queryKey] });
				});
			}
			options?.onSuccess?.(data);
		},
		onError: (error, variables, context) => {
			// Rollback optimistic updates if needed
			if (context) {
				queryClient.setQueryData(
					[options?.invalidateQueries?.[0] || "data"],
					context
				);
			}
			options?.onError?.(error);
		},
		onSettled: options?.onSettled,
	});
};

/**
 * PATCH mutation with optimistic updates
 */
export const useApiPatch = <T = any>(
	options?: MutationOptions & {
		invalidateQueries?: string[];
		optimisticUpdate?: (variables: any) => any;
	}
) => {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			endpoint,
			data,
			requestConfig,
		}: {
			endpoint: string;
			data?: any;
			requestConfig?: AxiosRequestConfig;
		}): Promise<T> => {
			try {
				const response = await apiPatch<T>(endpoint, data, requestConfig);
				return response;
			} catch (error) {
				const normalizedError = handleError(error);
				throw normalizedError;
			}
		},
		onMutate: options?.onMutate,
		onSuccess: (data, variables) => {
			// Invalidate related queries
			if (options?.invalidateQueries) {
				options.invalidateQueries.forEach((queryKey) => {
					queryClient.invalidateQueries({ queryKey: [queryKey] });
				});
			}
			options?.onSuccess?.(data);
		},
		onError: (error, variables, context) => {
			// Rollback optimistic updates if needed
			if (context) {
				queryClient.setQueryData(
					[options?.invalidateQueries?.[0] || "data"],
					context
				);
			}
			options?.onError?.(error);
		},
		onSettled: options?.onSettled,
	});
};
</file>

<file path="hooks/useDataFetcher.ts">
import { useCallback, useEffect } from "react";
import { useApiGet } from "./useApiClient";

export const useDataFetcher = <T>(endpoint?: string) => {
	// Remove the base URL from the endpoint if it's already included
	const cleanEndpoint = endpoint
		? endpoint.replace(/^https?:\/\/[^/]+/, "")
		: "";

	// Use the new API client hook - only when we have an endpoint
	const { data, error, isLoading, refetch } = useApiGet<any>(
		["data", cleanEndpoint],
		cleanEndpoint,
		{
			enabled: !!cleanEndpoint, // Only enable if we have an endpoint
		}
	);

	// Extract endpoint name from the URL to use as the data key
	const endpointName = cleanEndpoint.split("/").pop()?.split("?")[0];

	// Handle different response structures
	// Try the endpoint name first, then common patterns, then fallback to data itself
	const items = (endpointName && data?.[endpointName]) || data || [];

	// Create a fetch function that returns a Promise - memoized to prevent infinite loops
	const createFetchData = useCallback(() => {
		return async (): Promise<T[]> => {
			if (!cleanEndpoint) {
				return [];
			}

			try {
				const result = await refetch();
				const resultData = result.data;
				const resultItems =
					(endpointName && resultData?.[endpointName]) || resultData || [];
				return resultItems as T[];
			} catch (error) {
				throw error;
			}
		};
	}, [cleanEndpoint, refetch, endpointName]);

	return {
		data: items as T[],
		error: !cleanEndpoint ? null : error,
		isLoading: !cleanEndpoint ? false : isLoading,
		refetch: !cleanEndpoint ? () => Promise.resolve() : refetch,
		createFetchData,
	};
};
</file>

<file path="hooks/useErrorHandler.ts">
import { useState, useCallback } from "react";

export const useErrorHandler = () => {
	const [errorPopup, setErrorPopup] = useState<
		| string
		| {
				message: string;
				details?: Record<string, any>;
		  }
		| null
	>(null);
	const [showDialog, setShowDialog] = useState(false);
	const [flashRed, setFlashRed] = useState(false);

	const showError = useCallback((err: any) => {
		if (
			err &&
			typeof err === "object" &&
			"details" in err &&
			typeof err.details === "object"
		) {
			const { message, error, ...rest } = err.details;
			setErrorPopup({
				message: message || error || err.message || "An error occurred",
				details: Object.keys(rest).length > 0 ? rest : undefined,
			});
			setShowDialog(true);
			setFlashRed(true);
			setTimeout(() => setFlashRed(false), 400);
			return;
		}

		if (typeof err === "string") {
			// Try to parse as JSON
			try {
				const parsed = JSON.parse(err);
				if (typeof parsed === "object" && parsed !== null) {
					const { message, error, ...rest } = parsed;
					setErrorPopup({
						message: message || error || "An error occurred",
						details: Object.keys(rest).length > 0 ? rest : undefined,
					});
					setShowDialog(true);
					setFlashRed(true);
					setTimeout(() => setFlashRed(false), 400);
					return;
				}
			} catch {
				// Not JSON, just show as string
			}
			setErrorPopup(err);
		} else if (err && typeof err === "object") {
			const { message, error, ...rest } = err;
			setErrorPopup({
				message: message || error || "An error occurred",
				details: Object.keys(rest).length > 0 ? rest : undefined,
			});
		} else {
			setErrorPopup("An error occurred");
		}
		setShowDialog(true);
		setFlashRed(true);
		setTimeout(() => setFlashRed(false), 400);
	}, []);

	const clearError = useCallback(() => {
		setShowDialog(false);
		setErrorPopup(null);
	}, []);

	return {
		errorPopup,
		showDialog,
		flashRed,
		showError,
		clearError,
	};
};
</file>

<file path="hooks/useGridState.ts">
import { useState, useEffect, useCallback, useRef } from "react";
import type { GridApi, GridReadyEvent } from "ag-grid-enterprise";

/**
 * Grid state enum for tracking the complete lifecycle
 */
export type GridStateType = "loading" | "loaded" | "ready" | "error";

/**
 * Props interface for the useGridState hook
 *
 * @template T - The type of data objects managed by the grid
 */
interface UseGridStateProps<T> {
	/** Unique identifier for the grid instance, used for state persistence */
	gridId: string;
	/** Function to fetch data from the API or other data source */
	fetchData: () => Promise<T[]>;
}

/**
 * Hook for managing grid state and data loading
 *
 * This hook provides comprehensive state management for the grid including:
 * - Data loading and caching
 * - Grid API management
 * - Loading state management
 * - Grid state persistence and restoration
 * - Grid ready event handling
 *
 * The hook handles the complete lifecycle of grid data from initial
 * loading through state restoration and ongoing updates.
 *
 * @template T - The type of data objects managed by the grid
 * @param props - Configuration for grid state management
 * @returns Object containing grid state and management functions
 */
export const useGridState = <T>({
	gridId,
	fetchData,
}: UseGridStateProps<T>) => {
	// ===== CONSOLIDATED STATE MANAGEMENT =====
	/** Current row data array displayed in the grid */
	const [rowData, setRowData] = useState<T[]>([]);
	/** AG Grid API instance for grid operations */
	const [gridApi, setGridApi] = useState<GridApi | null>(null);
	/** Consolidated grid state tracking the complete lifecycle */
	const [gridState, setGridState] = useState<GridStateType>("loading");
	/** Saved grid state for restoration (currently not used) */
	const [savedState] = useState<any>(null);

	// Store the fetchData function in a ref to prevent infinite loops
	const fetchDataRef = useRef(fetchData);
	fetchDataRef.current = fetchData;

	// Data loading
	useEffect(() => {
		fetchDataRef
			.current()
			.then((data) => {
				setRowData(data);
				setGridState("loaded");
			})
			.catch((error) => {
				setGridState("error");
			});
	}, []); // Remove fetchData from dependencies to prevent infinite loops

	// Set up grid state when data is loaded
	useEffect(() => {
		if (gridState === "loaded") {
			// Show the grid immediately since we're not auto-loading state anymore
			setGridState("ready");
		}
	}, [gridState]);

	// Get current grid state (for manual saving)
	const getCurrentGridState = useCallback(() => {
		if (!gridApi) return null;

		try {
			const state = gridApi.getState();

			// Filter out the actions column from the saved state
			const filteredState = { ...state } as any;

			// Remove actions column from column state if it exists
			if (
				filteredState.columnState &&
				Array.isArray(filteredState.columnState)
			) {
				filteredState.columnState = filteredState.columnState.filter(
					(col: any) => col.colId !== "actions"
				);
			}

			// Remove actions column from column visibility if it exists
			if (
				filteredState.columnVisibility &&
				filteredState.columnVisibility.hiddenColIds
			) {
				filteredState.columnVisibility.hiddenColIds =
					filteredState.columnVisibility.hiddenColIds.filter(
						(colId: string) => colId !== "actions"
					);
			}

			// Remove actions column from pinned columns if it exists
			if (filteredState.columnPinned) {
				if (filteredState.columnPinned.leftColIds) {
					filteredState.columnPinned.leftColIds =
						filteredState.columnPinned.leftColIds.filter(
							(colId: string) => colId !== "actions"
						);
				}
				if (filteredState.columnPinned.rightColIds) {
					filteredState.columnPinned.rightColIds =
						filteredState.columnPinned.rightColIds.filter(
							(colId: string) => colId !== "actions"
						);
				}
			}

			return filteredState;
		} catch (error) {
			return null;
		}
	}, [gridApi]);

	// Grid ready event handler
	const onGridReady = useCallback((params: GridReadyEvent) => {
		setGridApi(params.api);
	}, []);

	// Force grid redraw when row data changes to ensure styling is updated
	useEffect(() => {
		if (gridApi && !gridApi.isDestroyed?.() && rowData && rowData.length > 0) {
			try {
				gridApi.redrawRows(); // Force class refresh on data change
			} catch (error) {
				// Ignore errors if grid is destroyed
			}
		}
	}, [rowData.length, gridApi]);

	// Check if grid should be shown - simplified to single state check
	const shouldShowGrid = gridState === "ready";

	// Computed loading state for backward compatibility
	const isLoading = gridState === "loading";

	return {
		rowData,
		setRowData,
		isLoading,
		setIsLoading: (loading: boolean) => {
			setGridState(loading ? "loading" : "ready");
		},
		gridApi,
		savedState,
		shouldShowGrid,
		onGridReady,
		getCurrentGridState,
		// Expose grid state for advanced use cases
		gridState,
		setGridState,
	};
};
</file>

<file path="hooks/useOptimizedRowManagement.ts">
import { useState, useCallback, useMemo, useEffect, useRef } from "react";
import React from "react";
import {
	generateNewRowTempId,
	isTempId,
} from "../../../../utils/tempIdGenerator";
import { apiBatch } from "../../../../utils/apiClient";
import type { ColDef } from "../BaseGrid";

/**
 * Interface representing the data structure returned from successful save operations
 */
interface SavedData {
	/** Array of newly added rows with server-assigned IDs */
	added: any[];
	/** Array of updated rows with current server data */
	updated: any[];
	/** Array of primary key values for deleted rows */
	deleted: string[];
}

/**
 * Props interface for the useOptimizedRowManagement hook
 */
interface UseOptimizedRowManagementProps<T> {
	/** API endpoint for data operations (optional for local-only grids) */
	endpoint?: string;
	/** Function to display error messages to the user */
	showError: (error: any) => void;
	/** Field name used as the primary key for row identification */
	primaryKey: string;
	/** Callback function called after successful save operations */
	onSaveSuccess: (savedData: SavedData) => void;
	/** Current row data array */
	rowData: T[];
	/** Function to update the row data array */
	setRowData: React.Dispatch<React.SetStateAction<T[]>>;
	/** Column definitions for the grid */
	colDefs: ColDef<T>[];
	/** AG Grid API instance for grid operations */
	gridApi?: any;
}

/**
 * Simple undo/redo operation type
 */
interface UndoRedoOperation {
	type: "add" | "update" | "remove";
	rowId: string;
	oldData?: any;
	newData?: any;
	timestamp: number;
}

/**
 * Optimized row management hook using AG Grid's native delta row data mode
 *
 * This hook provides row management functionality using AG Grid's built-in features:
 * - Native undo/redo for cell editing and row operations
 * - Delta row data mode for automatic change tracking
 * - Transaction-based row operations
 * - Visual feedback through row class rules
 *
 * Key features:
 * - Uses gridApi.applyTransaction() for all changes
 * - Relies on AG Grid's internal change detection
 * - Uses gridApi.getChanges() for save operations
 * - Simplified state management
 */
export const useOptimizedRowManagement = <T>({
	endpoint,
	showError,
	primaryKey,
	onSaveSuccess,
	rowData,
	setRowData,
	colDefs,
	gridApi,
}: UseOptimizedRowManagementProps<T>) => {
	// Add a state to force re-computation of hasUnsavedChanges
	const [changeCounter, setChangeCounter] = useState(0);

	// Simple undo/redo stack for row operations
	const [undoStack, setUndoStack] = useState<UndoRedoOperation[]>([]);
	const [redoStack, setRedoStack] = useState<UndoRedoOperation[]>([]);

	/**
	 * Helper function to clean row data by removing internal flags
	 */
	const cleanRowData = useCallback((row: any) => {
		const clean = { ...row };
		delete (clean as any).__isDirty;
		delete (clean as any).__isNewRow;
		delete (clean as any).__isDeleted;
		delete (clean as any).__isFailed;
		return clean;
	}, []);

	/**
	 * Adds an operation to the undo stack
	 */
	const addToUndoStack = useCallback(
		(operation: Omit<UndoRedoOperation, "timestamp">) => {
			const undoOp: UndoRedoOperation = {
				...operation,
				timestamp: Date.now(),
			};
			setUndoStack((prev) => [...prev, undoOp]);
			setRedoStack([]); // Clear redo stack when new operation is added
		},
		[]
	);

	/**
	 * Undo the last operation
	 */
	const undo = useCallback(() => {
		if (undoStack.length === 0 || !gridApi) return;

		const lastOp = undoStack[undoStack.length - 1];
		const remainingOps = undoStack.slice(0, -1);

		try {
			switch (lastOp.type) {
				case "add":
					// Undo add = remove
					gridApi.applyTransaction({ remove: [lastOp.newData] });
					break;
				case "update":
					// Undo update = restore old data
					if (lastOp.oldData) {
						gridApi.applyTransaction({ update: [lastOp.oldData] });
					}
					break;
				case "remove":
					// Undo remove = add back
					if (lastOp.oldData) {
						gridApi.applyTransaction({ add: [lastOp.oldData] });
					}
					break;
			}

			// Move operation to redo stack
			setUndoStack(remainingOps);
			setRedoStack((prev) => [...prev, lastOp]);

			// Increment change counter to trigger hasUnsavedChanges re-computation
			setChangeCounter((prev) => prev + 1);
		} catch (error) {}
	}, [undoStack, gridApi, setChangeCounter]);

	/**
	 * Redo the next operation
	 */
	const redo = useCallback(() => {
		if (redoStack.length === 0 || !gridApi) return;

		const nextOp = redoStack[redoStack.length - 1];
		const remainingRedoOps = redoStack.slice(0, -1);

		try {
			switch (nextOp.type) {
				case "add":
					// Redo add = add
					gridApi.applyTransaction({ add: [nextOp.newData] });
					break;
				case "update":
					// Redo update = apply new data
					if (nextOp.newData) {
						gridApi.applyTransaction({ update: [nextOp.newData] });
					}
					break;
				case "remove":
					// Redo remove = remove
					if (nextOp.newData) {
						gridApi.applyTransaction({ remove: [nextOp.newData] });
					}
					break;
			}

			// Move operation back to undo stack
			setRedoStack(remainingRedoOps);
			setUndoStack((prev) => [...prev, nextOp]);

			// Increment change counter to trigger hasUnsavedChanges re-computation
			setChangeCounter((prev) => prev + 1);
		} catch (error) {
			// Ignore redo errors
		}
	}, [redoStack, gridApi, setChangeCounter]);

	/**
	 * Checks if undo is available
	 */
	const canUndo = useMemo(() => undoStack.length > 0, [undoStack]);

	/**
	 * Checks if redo is available
	 */
	const canRedo = useMemo(() => redoStack.length > 0, [redoStack]);

	/**
	 * Adds a new row to the grid
	 */
	const addNewRow = useCallback(
		(defaultData: Partial<T> = {}) => {
			const tempId = generateNewRowTempId();
			const newRow = {
				[primaryKey]: tempId,
				...defaultData,
				__isNewRow: true,
			} as T;

			// Increment change counter to trigger hasUnsavedChanges re-computation
			setChangeCounter((prev) => prev + 1);

			// Clear any stale undo operations before adding new row
			// This prevents deleted rows from reappearing
			setUndoStack((prev) => {
				const currentNodes = gridApi?.getRenderedNodes() || [];
				const existingRowIds = currentNodes
					.map((node: any) => node.data?.[primaryKey])
					.filter(Boolean);

				return prev.filter((op) => {
					// Remove operations for rows that no longer exist in the grid
					if (op.type === "add" && op.newData) {
						return existingRowIds.includes(op.rowId);
					}
					return true;
				});
			});

			// Add to undo stack
			addToUndoStack({
				type: "add",
				rowId: tempId,
				newData: newRow,
			});

			if (gridApi) {
				gridApi.applyTransaction({ add: [newRow] });
			} else {
				setRowData((prev) => [...prev, newRow]);
			}

			return newRow;
		},
		[gridApi, primaryKey, setRowData, setChangeCounter, addToUndoStack]
	);

	/**
	 * Saves changes using AG Grid's native change detection
	 */
	const saveChanges = useCallback(async () => {
		if (!endpoint || !gridApi) return;

		try {
			// Get changes using AG Grid's native API (if available)
			let changes;
			if (typeof gridApi.getChanges === "function") {
				changes = gridApi.getChanges();
			} else {
				// Fallback: manually track changes using row data
				const currentData = gridApi
					.getRenderedNodes()
					.map((node: any) => node.data);
				const added = currentData.filter((row: any) => (row as any).__isNewRow);
				const updated = currentData.filter(
					(row: any) => (row as any).__isDirty && !(row as any).__isNewRow
				);
				const removed = currentData.filter(
					(row: any) => (row as any).__isDeleted
				);
				changes = { added, updated, removed };
			}

			const batch = {
				toAdd: changes.added || [],
				toUpdate: changes.updated || [],
				toDelete: changes.removed?.map((row: any) => row[primaryKey]) || [],
			};

			if (
				batch.toAdd.length === 0 &&
				batch.toUpdate.length === 0 &&
				batch.toDelete.length === 0
			) {
				return;
			}

			const result = await apiBatch(endpoint, batch);
			onSaveSuccess(result);

			// Clear change tracking after successful save
			// Reset change counter
			setChangeCounter(0);

			// Clear undo/redo stacks
			setUndoStack([]);
			setRedoStack([]);

			// Clear change tracking if available
			if (typeof gridApi.clearChanges === "function") {
				gridApi.clearChanges();
			} else {
				// Fallback: manually clear flags
				const allNodes = gridApi.getRenderedNodes();
				allNodes.forEach((node: any) => {
					if (node.data) {
						node.data.__isDirty = false;
						node.data.__isNewRow = false;
						node.data.__isDeleted = false;
						node.data.__isFailed = false;
					}
				});
				gridApi.refreshCells();
			}
		} catch (error) {
			showError(error);
		}
	}, [endpoint, gridApi, onSaveSuccess, showError, primaryKey]);

	/**
	 * Clears all pending changes
	 */
	const clearChanges = useCallback(() => {
		if (!gridApi) return;

		// Check if grid is destroyed
		if (gridApi.isDestroyed && gridApi.isDestroyed()) {
			return;
		}

		// Reset change counter
		setChangeCounter(0);

		// Clear undo/redo stacks
		setUndoStack([]);
		setRedoStack([]);

		// Check if AG Grid's native clearChanges is available
		if (typeof gridApi.clearChanges === "function") {
			gridApi.clearChanges();
		} else {
			// Fallback: manually clear flags
			try {
				const allNodes = gridApi.getRenderedNodes();
				if (allNodes && Array.isArray(allNodes)) {
					allNodes.forEach((node: any) => {
						if (node.data) {
							node.data.__isDirty = false;
							node.data.__isNewRow = false;
							node.data.__isDeleted = false;
							node.data.__isFailed = false;
						}
					});
					gridApi.refreshCells();
				}
			} catch (error) {
				// Grid might be destroyed, just clear the state
			}
		}
	}, [gridApi, setChangeCounter, setUndoStack, setRedoStack]);

	/**
	 * Deletes selected rows
	 */
	const deleteSelectedRows = useCallback(
		(api: any) => {
			const selectedNodes = api.getSelectedNodes();
			if (selectedNodes.length > 0) {
				// Separate new rows from existing rows
				const newRows = selectedNodes.filter(
					(node: any) => node.data.__isNewRow
				);
				const existingRows = selectedNodes.filter(
					(node: any) => !node.data.__isNewRow
				);

				// For new rows, just remove them completely (they don't exist in DB yet)
				if (newRows.length > 0) {
					// Remove the corresponding "add" operations from undo stack
					// since we're removing the rows completely
					const rowIdsToRemove = newRows.map(
						(node: any) => node.data[primaryKey]
					);
					setUndoStack((prev) =>
						prev.filter(
							(op) => !(op.type === "add" && rowIdsToRemove.includes(op.rowId))
						)
					);

					// Remove new rows completely
					api.applyTransaction({
						remove: newRows.map((node: any) => node.data),
					});
				}

				// For existing rows, mark them as deleted
				if (existingRows.length > 0) {
					// Add to undo stack for existing rows
					existingRows.forEach((node: any) => {
						const rowData = node.data;
						addToUndoStack({
							type: "remove",
							rowId: rowData[primaryKey],
							oldData: rowData,
						});
					});

					// Mark existing rows as deleted
					const updatedRows = existingRows.map((node: any) => ({
						...node.data,
						__isDeleted: true,
						__isDirty: false,
						__isNewRow: false,
						__isFailed: false,
					}));

					// Update the rows to mark them as deleted
					api.applyTransaction({
						update: updatedRows,
					});
				}

				// Increment change counter
				setChangeCounter((prev) => prev + 1);

				// Force refresh to update styling
				if (api && !api.isDestroyed?.()) {
					try {
						api.refreshCells({ force: true });
						if (!api.isDestroyed?.()) {
							api.redrawRows();
						}
					} catch (error) {
						// Ignore refresh errors
					}
				}
			}
		},
		[primaryKey, addToUndoStack, setChangeCounter]
	);

	/**
	 * Duplicates selected rows
	 */
	const duplicateSelectedRow = useCallback(
		(api: any) => {
			const selectedNodes = api.getSelectedNodes();
			if (selectedNodes.length > 0) {
				const newRows = selectedNodes.map((node: any) => ({
					...node.data,
					[primaryKey]: generateNewRowTempId(),
					__isNewRow: true,
				}));
				api.applyTransaction({ add: newRows });
			}
		},
		[primaryKey]
	);

	/**
	 * Gets the row ID for AG Grid
	 */
	const getRowId = useCallback(
		(params: any) => params.data[primaryKey].toString(),
		[primaryKey]
	);

	/**
	 * Gets context menu items
	 */
	const getContextMenuItems = useCallback(
		(params: any) => {
			const items = [
				"copy",
				"copyWithHeaders",
				"paste",
				{
					name: "Duplicate Row",
					action: () => duplicateSelectedRow(params.api),
				},
				{
					name: "Delete Row",
					action: () => deleteSelectedRows(params.api),
				},
			];
			return items;
		},
		[deleteSelectedRows, duplicateSelectedRow]
	);

	/**
	 * Handles cell value changes
	 */
	const handleCellValueChanged = useCallback(
		(event: any) => {
			const rowId = event.data[primaryKey];
			if (!rowId) return;

			// Mark row as dirty if it's not a new row
			if (!isTempId(rowId)) {
				// Create old data for undo
				const oldData = {
					...event.data,
					[event.column.colId]: event.oldValue,
					__isDirty: false,
					__isNewRow: false,
					__isDeleted: false,
				};

				// Create new data for undo
				const newData = {
					...event.data,
					__isDirty: true,
					__isNewRow: false,
					__isDeleted: false,
				};

				// Add to undo stack
				addToUndoStack({
					type: "update",
					rowId,
					oldData,
					newData,
				});

				// Update the row data directly
				event.data.__isDirty = true;
				event.data.__isNewRow = false;
				event.data.__isDeleted = false;

				// Increment change counter to trigger hasUnsavedChanges re-computation
				setChangeCounter((prev) => prev + 1);

				// Force immediate visual update
				if (gridApi && !gridApi.isDestroyed?.()) {
					try {
						// Refresh the specific row to update styling
						gridApi.refreshCells({ rowNodes: [event.node], force: true });

						// Also refresh the entire grid to ensure all styling is updated
						setTimeout(() => {
							if (gridApi && !gridApi.isDestroyed?.()) {
								gridApi.refreshCells({ force: true });
								// Force a re-render of the row to update class rules
								if (!gridApi.isDestroyed?.()) {
									gridApi.redrawRows({ rowNodes: [event.node] });
								}
							}
						}, 0);
					} catch (error) {
						// Ignore refresh errors
					}
				}
			}
		},
		[gridApi, primaryKey, setChangeCounter, addToUndoStack]
	);

	/**
	 * Handles cell editing stopped
	 */
	const handleCellEditingStopped = useCallback(() => {
		// Force a refresh when editing stops to ensure visual updates
		if (gridApi && !gridApi.isDestroyed?.()) {
			try {
				gridApi.refreshCells({ force: true });
			} catch (error) {
				// Ignore refresh errors
			}
		}
	}, [gridApi]);

	/**
	 * Gets row class for styling
	 */
	const getRowClass = useCallback((params: any) => {
		const classes = [];
		if (params.data) {
			if ((params.data as any).__isNewRow) {
				classes.push("ag-row-new");
			} else if ((params.data as any).__isDirty) {
				classes.push("ag-row-dirty");
			} else if ((params.data as any).__isDeleted) {
				classes.push("ag-row-deleted");
			} else if ((params.data as any).__isFailed) {
				classes.push("ag-row-failed");
			}
		}
		return classes.join(" ");
	}, []);

	/**
	 * Gets cell class for styling
	 */
	const getCellClass = useCallback((params: any) => {
		const classes = [];
		if (params.data) {
			if ((params.data as any).__isNewRow) {
				classes.push("ag-cell-new");
			} else if ((params.data as any).__isDirty) {
				classes.push("ag-cell-dirty");
			} else if ((params.data as any).__isDeleted) {
				classes.push("ag-cell-deleted");
			} else if ((params.data as any).__isFailed) {
				classes.push("ag-cell-failed");
			}
		}
		return classes.join(" ");
	}, []);

	/**
	 * Computed value for unsaved changes
	 */
	const hasUnsavedChanges = useMemo(() => {
		if (!gridApi) {
			return false;
		}

		// Check if grid is destroyed
		if (gridApi.isDestroyed && gridApi.isDestroyed()) {
			return false;
		}

		// Check if AG Grid's native hasChanges is available
		if (typeof gridApi.hasChanges === "function") {
			try {
				const hasChanges = gridApi.hasChanges();
				return hasChanges;
			} catch (error) {
				// Fall back to manual check
			}
		}

		// Fallback: manually check for changes
		try {
			const currentData = gridApi
				.getRenderedNodes()
				.map((node: any) => node.data);

			const hasChanges = currentData.some(
				(row: any) =>
					(row as any).__isNewRow ||
					(row as any).__isDirty ||
					(row as any).__isDeleted
			);

			return hasChanges;
		} catch (error) {
			return false;
		}
	}, [gridApi, changeCounter]);

	return {
		hasUnsavedChanges,
		addNewRow,
		saveChanges,
		clearChanges,
		getRowId,
		getContextMenuItems,
		handleCellValueChanged,
		handleCellEditingStopped,
		deleteSelectedRows,
		duplicateSelectedRow,
		getRowClass,
		getCellClass,
		// Add undo/redo functions
		undo,
		redo,
		canUndo,
		canRedo,
	};
};
</file>

<file path="hooks/useUnsavedChangesWarning.ts">
import { useEffect, useCallback } from "react";

interface UseUnsavedChangesWarningProps {
	hasUnsavedChanges: boolean;
	onConfirmNavigation?: () => void;
}

/**
 * Hook to warn users about unsaved changes when navigating away or refreshing
 *
 * This hook:
 * - Shows a browser warning when trying to close/refresh the page
 * - Provides a custom confirmation dialog for grid refresh actions
 * - Prevents accidental data loss
 */
export const useUnsavedChangesWarning = ({
	hasUnsavedChanges,
	onConfirmNavigation,
}: UseUnsavedChangesWarningProps) => {
	// Handle browser navigation (close, refresh, back button)
	useEffect(() => {
		const handleBeforeUnload = (event: BeforeUnloadEvent) => {
			if (hasUnsavedChanges) {
				event.preventDefault();
				event.returnValue =
					"You have unsaved changes. Are you sure you want to leave?";
				return "You have unsaved changes. Are you sure you want to leave?";
			}
		};

		window.addEventListener("beforeunload", handleBeforeUnload);
		return () => window.removeEventListener("beforeunload", handleBeforeUnload);
	}, [hasUnsavedChanges]);

	// Custom confirmation for grid refresh
	const confirmRefresh = useCallback(() => {
		if (hasUnsavedChanges) {
			const confirmed = window.confirm(
				"You have unsaved changes. Refreshing will lose all unsaved data. Are you sure you want to continue?"
			);
			if (confirmed && onConfirmNavigation) {
				onConfirmNavigation();
			}
			return confirmed;
		}
		return true; // No unsaved changes, allow refresh
	}, [hasUnsavedChanges, onConfirmNavigation]);

	return {
		confirmRefresh,
	};
};
</file>

<file path="layouts/index.ts">
/**
 * Layout Management Module
 *
 * This module provides a complete layout management system for AG Grid components.
 * It includes hooks, components, and utilities for managing grid layouts in a
 * general-purpose, reusable manner.
 */

// Core layout management hook
export { useLayoutManager } from "./useLayoutManager";

// React context for sharing layout state
export { LayoutProvider, useLayoutContext } from "./LayoutContext";

// Layout components
export { default as LayoutsToolPanel } from "./LayoutsToolPanel";
export { default as LayoutStatusPanel } from "./LayoutStatusPanel";

// Types and interfaces
export type {
	Layout,
	LayoutWithData,
	UseLayoutManagerProps,
	LayoutChangeCallback,
	LayoutSaveCallback,
	LayoutsToolPanelProps,
	LayoutStatusPanelProps,
	LayoutContextValue,
} from "./types";
</file>

<file path="layouts/LayoutContext.tsx">
import React, { createContext, useContext, ReactNode } from "react";
import { LayoutContextValue } from "./types";

/**
 * React context for sharing layout management state across components
 */
const LayoutContext = createContext<LayoutContextValue | null>(null);

/**
 * Props interface for the LayoutProvider component
 */
interface LayoutProviderProps {
	/** The layout context value to provide */
	value: LayoutContextValue;
	/** Child components that will have access to the layout context */
	children: ReactNode;
}

/**
 * LayoutProvider - React context provider for layout management
 *
 * This component provides layout management state and functions to all
 * child components through React's context system. This allows components
 * to access layout functionality without prop drilling.
 *
 * @param value - The layout context value containing state and functions
 * @param children - Child components that will have access to the context
 * @returns JSX element wrapping children with layout context
 */
export const LayoutProvider: React.FC<LayoutProviderProps> = ({
	value,
	children,
}) => {
	return (
		<LayoutContext.Provider value={value}>{children}</LayoutContext.Provider>
	);
};

/**
 * Custom hook for accessing layout context
 *
 * This hook provides a convenient way to access the layout context
 * from any component within the LayoutProvider tree. It includes
 * proper error handling for when the hook is used outside of a provider.
 *
 * @returns The layout context value
 * @throws Error if used outside of LayoutProvider
 */
export const useLayoutContext = (): LayoutContextValue => {
	const context = useContext(LayoutContext);

	if (!context) {
		throw new Error("useLayoutContext must be used within a LayoutProvider");
	}

	return context;
};
</file>

<file path="layouts/LayoutStatusPanel.tsx">
import React, { useState, useEffect, useCallback } from "react";
import { apiGet } from "../../../../utils/apiClient";
import { API_ENDPOINTS } from "../../../../config/api";
import { Layout, LayoutStatusPanelProps } from "./types";

/**
 * LayoutStatusPanel - Custom AG Grid status panel for layout information
 *
 * This component displays in the grid's status bar and provides:
 * - Current layout name display
 * - Quick save button for the current layout
 * - Loading state while fetching layout information
 *
 * The component automatically loads the default layout on mount
 * and provides a convenient way for users to save their current
 * grid state to the active layout.
 *
 * @param gridId - Unique identifier for the grid instance
 * @param onLayoutSave - Callback for when the save button is clicked
 * @returns JSX element representing the layout status panel
 */
const LayoutStatusPanel: React.FC<LayoutStatusPanelProps> = ({
	gridId,
	onLayoutSave,
}) => {
	// State for current layout information and loading state
	const [currentLayout, setCurrentLayout] = useState<Layout | null>(null);
	const [isLoading, setIsLoading] = useState(true);

	/**
	 * Loads the default layout for the current grid
	 *
	 * This function:
	 * - Makes an API call to ensure the default layout exists
	 * - Sets the current layout state with the default layout info
	 * - Handles authentication errors and redirects to login if needed
	 * - Updates the loading state appropriately
	 */
	const loadDefaultLayout = useCallback(async () => {
		try {
			setIsLoading(true);
			const response = await apiGet(API_ENDPOINTS.GRID_LAYOUT_DEFAULT(gridId));
			setCurrentLayout(response);
		} catch (err: any) {
			console.error("Error loading default layout:", err);
			if (err.response?.status === 401) {
				localStorage.removeItem("token");
				window.location.href = "/login";
			}
		} finally {
			setIsLoading(false);
		}
	}, [gridId]);

	// Load the default layout when the component mounts
	useEffect(() => {
		loadDefaultLayout();
	}, [loadDefaultLayout]);

	/**
	 * Handles the save layout button click
	 *
	 * This function triggers the save operation by calling the onLayoutSave
	 * callback with the current layout ID. The actual grid state capture
	 * and saving is handled by the parent component.
	 */
	const handleSaveLayout = () => {
		if (currentLayout) {
			onLayoutSave({ layoutId: currentLayout.layout_id });
		}
	};

	// Loading state while fetching layout information
	if (isLoading) {
		return (
			<div style={{ display: "flex", alignItems: "center", gap: "10px" }}>
				<span>Loading layout...</span>
			</div>
		);
	}

	// Main component render with layout info and save button
	return (
		<div style={{ display: "flex", alignItems: "center", gap: "10px" }}>
			<span style={{ fontSize: "12px", color: "#666" }}>
				Layout: <strong>{currentLayout?.layout_name || "My Layout"}</strong>
			</span>
			<button
				onClick={handleSaveLayout}
				style={{
					padding: "4px 8px",
					background: "#1976d2",
					color: "white",
					border: "none",
					borderRadius: "4px",
					cursor: "pointer",
					fontSize: "11px",
				}}
			>
				Save Layout
			</button>
		</div>
	);
};

export default LayoutStatusPanel;
</file>

<file path="layouts/LayoutsToolPanel.tsx">
import React, { useState, useEffect, useCallback } from "react";
import { useApiGet, useApiPost, useApiDelete } from "../hooks/useApiClient";
import { API_ENDPOINTS } from "../../../../config/api";
import { Layout, LayoutsToolPanelProps } from "./types";

/**
 * LayoutsToolPanel - Custom AG Grid tool panel for layout management
 *
 * This component provides a user interface for managing grid layouts:
 * - Displaying available layouts for the current grid
 * - Selecting and applying different layouts
 * - Creating new layouts
 * - Deleting existing layouts (except the default "My Layout")
 * - Saving changes to the current layout
 *
 * The component integrates with the backend API to persist layout data
 * and provides real-time feedback for user actions.
 *
 * @param gridId - Unique identifier for the grid instance
 * @param onLayoutChange - Callback for when a layout is selected
 * @param onLayoutSave - Callback for when a layout is saved
 * @returns JSX element representing the layouts tool panel
 */
const LayoutsToolPanel: React.FC<LayoutsToolPanelProps> = ({
	gridId,
	onLayoutChange,
	onLayoutSave,
}) => {
	// State management for layouts and UI
	const [selectedLayout, setSelectedLayout] = useState<string | null>(null);
	const [error, setError] = useState<string | null>(null);
	const [newLayoutName, setNewLayoutName] = useState("");
	const [showCreateForm, setShowCreateForm] = useState(false);

	// Use the new API client hooks
	const {
		data: layoutsData,
		error: layoutsError,
		isLoading,
	} = useApiGet<any>(["layouts", gridId], API_ENDPOINTS.GRID_LAYOUTS(gridId), {
		onSuccess: (data) => {
			const layouts = data.gridLayout || [];
			// Set the default layout as selected if available
			const defaultLayout = layouts.find((layout: Layout) => layout.is_default);
			if (defaultLayout) {
				setSelectedLayout(defaultLayout.layout_id);
			} else if (layouts.length > 0) {
				setSelectedLayout(layouts[0].layout_id);
			}
		},
		onError: (error) => {
			setError("Failed to load layouts");
		},
	});

	const createLayoutMutation = useApiPost<any>({
		invalidateQueries: [`layouts-${gridId}`],
		onSuccess: (data) => {
			const newLayout = data.gridLayout;
			setNewLayoutName("");
			setShowCreateForm(false);
			setSelectedLayout(newLayout.layout_id);
		},
		onError: (error) => {
			if (error?.status === 409) {
				setError("Layout name already exists");
			} else {
				setError("Failed to create layout");
			}
		},
	});

	const deleteLayoutMutation = useApiDelete<any>({
		invalidateQueries: [`layouts-${gridId}`],
		onSuccess: () => {
			// If the deleted layout was selected, select the default layout
			const layouts = layoutsData?.gridLayout || [];
			const defaultLayout = layouts.find((layout: Layout) => layout.is_default);
			if (defaultLayout) {
				setSelectedLayout(defaultLayout.layout_id);
			}
		},
		onError: () => {
			setError("Failed to delete layout");
		},
	});

	const layouts = layoutsData?.gridLayout || [];

	// Handle layout selection
	const handleLayoutSelect = useCallback(
		async (layoutId: string) => {
			try {
				setSelectedLayout(layoutId);
				// For loading individual layouts, we'll use the existing apiGet function
				// since we don't need caching for this specific use case
				const response = await fetch(
					API_ENDPOINTS.GRID_LAYOUT(gridId, layoutId),
					{
						headers: {
							Authorization: `Bearer ${localStorage.getItem("token")}`,
							"Content-Type": "application/json",
						},
					}
				);
				const data = await response.json();
				const layoutData = data.gridLayout.layout_data;
				onLayoutChange(layoutData);
			} catch (err: any) {
				console.error("Error loading layout:", err);
				setError("Failed to load layout");
			}
		},
		[gridId, onLayoutChange]
	);

	/**
	 * Saves the current grid state to the selected layout
	 *
	 * This function triggers the save operation by calling the onLayoutSave
	 * callback, which will capture the current grid state and persist it
	 * to the backend for the selected layout.
	 */
	const handleSaveLayout = useCallback(async () => {
		if (!selectedLayout) return;

		try {
			// Get current grid state from the grid API
			// This will be passed from the parent component
			onLayoutSave({ layoutId: selectedLayout });
		} catch (err: any) {
			console.error("Error saving layout:", err);
			setError("Failed to save layout");
		}
	}, [selectedLayout, onLayoutSave]);

	/**
	 * Creates a new layout with the specified name
	 *
	 * This function:
	 * - Validates the layout name is not empty
	 * - Makes an API call to create a new layout
	 * - Adds the new layout to the local state
	 * - Sets the new layout as selected
	 * - Handles duplicate name errors and authentication issues
	 *
	 * @param newLayoutName - The name for the new layout
	 */
	const handleCreateLayout = useCallback(async () => {
		if (!newLayoutName.trim()) return;

		try {
			await createLayoutMutation.mutateAsync({
				endpoint: API_ENDPOINTS.GRID_LAYOUTS(gridId),
				data: {
					layoutName: newLayoutName.trim(),
					layoutData: {}, // Empty layout data
					isDefault: false,
				},
			});
		} catch (err: any) {
			console.error("Error creating layout:", err);
		}
	}, [gridId, newLayoutName, createLayoutMutation]);

	/**
	 * Deletes a layout from the database and updates the UI
	 *
	 * This function:
	 * - Prevents deletion of the default "My Layout"
	 * - Makes an API call to delete the layout
	 * - Removes the layout from the local state
	 * - Selects the default layout if the deleted layout was selected
	 * - Handles authentication errors and user feedback
	 *
	 * @param layoutId - The ID of the layout to delete
	 * @param layoutName - The name of the layout (for validation)
	 */
	const handleDeleteLayout = useCallback(
		async (layoutId: string, layoutName: string) => {
			if (layoutName === "My Layout") {
				setError("Cannot delete the default layout");
				return;
			}

			try {
				await deleteLayoutMutation.mutateAsync({
					endpoint: API_ENDPOINTS.GRID_LAYOUT(gridId, layoutId),
				});
			} catch (err: any) {
				console.error("Error deleting layout:", err);
			}
		},
		[gridId, deleteLayoutMutation]
	);

	// Loading state
	if (isLoading) {
		return (
			<div className="ag-tool-panel-wrapper">
				<div className="ag-tool-panel-group">
					<div className="ag-tool-panel-group-title">Layouts</div>
					<div className="ag-tool-panel-group-content">
						<div>Loading layouts...</div>
					</div>
				</div>
			</div>
		);
	}

	// Main component render
	return (
		<div className="ag-tool-panel-wrapper">
			<div className="ag-tool-panel-group">
				<div className="ag-tool-panel-group-title">Layouts</div>
				<div className="ag-tool-panel-group-content">
					{error && (
						<div
							className="ag-error-message"
							style={{ color: "red", marginBottom: "10px" }}
						>
							{error}
						</div>
					)}

					{/* Layout List */}
					<div className="ag-layout-list">
						{layouts.map((layout: Layout) => (
							<div
								key={layout.layout_id}
								className={`ag-layout-item ${
									selectedLayout === layout.layout_id
										? "ag-layout-item-selected"
										: ""
								}`}
								onClick={() => handleLayoutSelect(layout.layout_id)}
							>
								<div className="ag-layout-item-name">{layout.layout_name}</div>
								{layout.layout_name !== "My Layout" && (
									<button
										className="ag-layout-delete-btn"
										onClick={(e) => {
											e.stopPropagation();
											handleDeleteLayout(layout.layout_id, layout.layout_name);
										}}
									>
										×
									</button>
								)}
							</div>
						))}
					</div>

					{/* Create Layout Form */}
					{showCreateForm ? (
						<div className="ag-create-layout-form">
							<input
								type="text"
								value={newLayoutName}
								onChange={(e) => setNewLayoutName(e.target.value)}
								placeholder="Enter layout name"
								className="ag-layout-name-input"
							/>
							<div className="ag-layout-form-buttons">
								<button
									onClick={handleCreateLayout}
									disabled={!newLayoutName.trim()}
									className="ag-layout-create-btn"
								>
									Create
								</button>
								<button
									onClick={() => {
										setShowCreateForm(false);
										setNewLayoutName("");
									}}
									className="ag-layout-cancel-btn"
								>
									Cancel
								</button>
							</div>
						</div>
					) : (
						<button
							onClick={() => setShowCreateForm(true)}
							className="ag-layout-create-new-btn"
						>
							+ Create New Layout
						</button>
					)}

					{/* Save Layout Button */}
					{selectedLayout && (
						<button
							onClick={handleSaveLayout}
							className="ag-layout-save-btn"
							disabled={
								createLayoutMutation.isPending || deleteLayoutMutation.isPending
							}
						>
							Save Layout
						</button>
					)}
				</div>
			</div>
		</div>
	);
};

export default LayoutsToolPanel;
</file>

<file path="layouts/types.ts">
/**
 * Layout Management Types
 *
 * This file contains all shared types and interfaces for the layout management module.
 * These types define the structure for grid layouts, including their data, metadata,
 * and the interfaces used by layout management components and hooks.
 */

/**
 * Interface representing a grid layout stored in the database
 *
 * This interface defines the structure of a layout as stored in the backend,
 * including metadata about the layout and its relationship to the grid.
 */
export interface Layout {
	/** Unique identifier for the layout */
	layout_id: string;
	/** User-friendly name for the layout */
	layout_name: string;
	/** Whether this is the default layout for the grid */
	is_default: boolean;
	/** When the layout was created */
	created_at: string;
	/** When the layout was last updated */
	updated_at: string;
}

/**
 * Interface representing a layout with its data for internal use
 *
 * This interface extends the base Layout interface to include the actual
 * grid state data that defines how the grid should be configured.
 * The layout_data contains AG Grid state information like column order,
 * filters, sorting, and other grid configuration.
 */
export interface LayoutWithData extends Layout {
	/** The actual grid state data for this layout */
	layout_data: any;
}

/**
 * Interface for layout management hook props
 */
export interface UseLayoutManagerProps {
	/** Unique identifier for the grid instance */
	gridId: string;
	/** AG Grid API instance for state manipulation */
	gridApi: any;
}

/**
 * Interface for layout change callback
 */
export interface LayoutChangeCallback {
	/** The layout data to apply to the grid */
	layoutData: any;
}

/**
 * Interface for layout save callback
 */
export interface LayoutSaveCallback {
	/** The ID of the layout to save the current state to */
	layoutId: string;
}

/**
 * Interface for layout tool panel props
 */
export interface LayoutsToolPanelProps {
	/** Unique identifier for the grid instance */
	gridId: string;
	/** Callback function when a layout is selected/changed */
	onLayoutChange: (layoutData: any) => void;
	/** Callback function when a layout is saved */
	onLayoutSave: (layoutData: any) => void;
}

/**
 * Interface for layout status panel props
 */
export interface LayoutStatusPanelProps {
	/** Unique identifier for the grid instance */
	gridId: string;
	/** Callback function when the layout save button is clicked */
	onLayoutSave: (layoutData: any) => void;
}

/**
 * Interface for layout context value
 */
export interface LayoutContextValue {
	/** Current active layout */
	currentLayout: LayoutWithData | null;
	/** Loading state */
	isLoading: boolean;
	/** Load a specific layout */
	loadLayout: (layoutId: string) => Promise<LayoutWithData>;
	/** Save current grid state to a layout */
	saveLayout: (layoutId: string) => Promise<boolean>;
	/** Ensure default layout exists and load it */
	ensureDefaultLayout: () => Promise<LayoutWithData>;
	/** Handle layout change by applying to grid */
	handleLayoutChange: (layoutData: any) => void;
	/** Handle layout save operation */
	handleLayoutSave: (params: LayoutSaveCallback) => Promise<void>;
}
</file>

<file path="layouts/useLayoutManager.ts">
import { useState, useCallback } from "react";
import { useApiGet, useApiPut } from "../hooks/useApiClient";
import { API_ENDPOINTS } from "../../../../config/api";
import {
	UseLayoutManagerProps,
	LayoutWithData,
	LayoutSaveCallback,
} from "./types";

/**
 * Custom hook for managing grid layout functionality
 *
 * This hook encapsulates all layout-related operations including:
 * - Loading and saving layouts
 * - Handling layout changes
 * - Managing the current active layout
 * - Providing layout state to the grid
 * - Ensuring default layout exists
 *
 * The hook is designed to be general-purpose and not tied to any specific
 * project or domain, making it reusable across different grid implementations.
 *
 * @param gridId - Unique identifier for the grid instance
 * @param gridApi - AG Grid API instance for state manipulation
 * @returns Object containing layout management functions and state
 */
export const useLayoutManager = ({
	gridId,
	gridApi,
}: UseLayoutManagerProps) => {
	const [currentLayout, setCurrentLayout] = useState<LayoutWithData | null>(
		null
	);

	// Use the new API client hooks
	const loadLayoutMutation = useApiPut<LayoutWithData>({
		invalidateQueries: [`layouts-${gridId}`],
	});

	const saveLayoutMutation = useApiPut<boolean>({
		invalidateQueries: [`layouts-${gridId}`],
	});

	/**
	 * Loads a specific layout and applies it to the grid
	 *
	 * This function:
	 * - Fetches the layout data from the backend
	 * - Updates the current layout state
	 * - Applies the layout data to the grid using AG Grid's setState
	 * - Handles authentication and error scenarios
	 *
	 * @param layoutId - The ID of the layout to load
	 * @returns Promise resolving to the loaded layout data
	 */
	const loadLayout = useCallback(
		async (layoutId: string): Promise<LayoutWithData> => {
			try {
				const layout = await loadLayoutMutation.mutateAsync({
					endpoint: API_ENDPOINTS.GRID_LAYOUT(gridId, layoutId),
					data: {},
				});
				setCurrentLayout(layout);

				// Apply the layout data to the grid
				if (layout.layout_data && Object.keys(layout.layout_data).length > 0) {
					gridApi?.setState(layout.layout_data);
				}

				return layout;
			} catch (err: any) {
				console.error("Error loading layout:", err);
				throw err;
			}
		},
		[gridId, gridApi, loadLayoutMutation]
	);

	/**
	 * Saves the current grid state to a specific layout
	 *
	 * This function:
	 * - Captures the current grid state using AG Grid's getState
	 * - Filters out the actions column from the saved state
	 * - Updates the layout in the backend
	 * - Updates the current layout state if it matches
	 * - Handles authentication and error scenarios
	 *
	 * @param layoutId - The ID of the layout to save the current state to
	 * @returns Promise resolving to true if successful
	 */
	const saveLayout = useCallback(
		async (layoutId: string): Promise<boolean> => {
			if (!gridApi) return false;

			try {
				// Get current grid state
				const currentState = gridApi.getState();

				// Filter out the actions column from the saved state
				const filteredState = { ...currentState } as any;

				// Remove actions column from column state if it exists
				if (
					filteredState.columnState &&
					Array.isArray(filteredState.columnState)
				) {
					filteredState.columnState = filteredState.columnState.filter(
						(col: any) => col.colId !== "actions"
					);
				}

				// Remove actions column from column visibility if it exists
				if (
					filteredState.columnVisibility &&
					filteredState.columnVisibility.hiddenColIds
				) {
					filteredState.columnVisibility.hiddenColIds =
						filteredState.columnVisibility.hiddenColIds.filter(
							(colId: string) => colId !== "actions"
						);
				}

				// Remove actions column from pinned columns if it exists
				if (filteredState.columnPinned) {
					if (filteredState.columnPinned.leftColIds) {
						filteredState.columnPinned.leftColIds =
							filteredState.columnPinned.leftColIds.filter(
								(colId: string) => colId !== "actions"
							);
					}
					if (filteredState.columnPinned.rightColIds) {
						filteredState.columnPinned.rightColIds =
							filteredState.columnPinned.rightColIds.filter(
								(colId: string) => colId !== "actions"
							);
					}
				}

				// Update the layout with current state
				await saveLayoutMutation.mutateAsync({
					endpoint: API_ENDPOINTS.GRID_LAYOUT(gridId, layoutId),
					data: {
						layoutData: filteredState,
					},
				});

				// Update current layout state
				if (currentLayout && currentLayout.layout_id === layoutId) {
					setCurrentLayout({
						...currentLayout,
						layout_data: filteredState,
					});
				}

				return true;
			} catch (err: any) {
				console.error("Error saving layout:", err);
				throw err;
			}
		},
		[gridId, gridApi, currentLayout, saveLayoutMutation]
	);

	/**
	 * Ensures the default layout exists and loads it
	 *
	 * This function:
	 * - Makes an API call to ensure the default layout exists
	 * - Sets the current layout state with the default layout info
	 * - Applies the layout data to the grid if it has data
	 * - Handles authentication and error scenarios
	 *
	 * @returns Promise resolving to the default layout data
	 */
	const ensureDefaultLayout = useCallback(async (): Promise<LayoutWithData> => {
		try {
			const layout = await loadLayoutMutation.mutateAsync({
				endpoint: API_ENDPOINTS.GRID_LAYOUT_DEFAULT(gridId),
				data: {},
			});
			setCurrentLayout(layout);

			// Apply the layout data to the grid if it has data
			if (layout.layout_data && Object.keys(layout.layout_data).length > 0) {
				gridApi?.setState(layout.layout_data);
			}

			return layout;
		} catch (err: any) {
			console.error("Error ensuring default layout:", err);
			throw err;
		}
	}, [gridId, gridApi, loadLayoutMutation]);

	/**
	 * Handles layout changes by applying the new layout state to the grid
	 *
	 * This function is called when a user selects a different layout from the sidebar.
	 * It takes the layout data and applies it to the current grid state using AG Grid's setState method.
	 *
	 * @param layoutData - The layout state object containing grid configuration
	 */
	const handleLayoutChange = useCallback(
		(layoutData: any) => {
			if (layoutData && Object.keys(layoutData).length > 0) {
				gridApi?.setState(layoutData);
			}
		},
		[gridApi]
	);

	/**
	 * Saves the current grid state to the selected layout
	 *
	 * This function is called when a user clicks the "Save Layout" button.
	 * It captures the current grid state (column order, filters, sorting, etc.)
	 * and saves it to the database for the specified layout.
	 *
	 * @param params - Object containing the layout ID to save to
	 */
	const handleLayoutSave = useCallback(
		async (params: LayoutSaveCallback) => {
			try {
				await saveLayout(params.layoutId);
			} catch (error) {
				console.error("Error saving layout:", error);
			}
		},
		[saveLayout]
	);

	return {
		currentLayout,
		isLoading: loadLayoutMutation.isPending || saveLayoutMutation.isPending,
		loadLayout,
		saveLayout,
		ensureDefaultLayout,
		handleLayoutChange,
		handleLayoutSave,
	};
};
</file>

<file path="README.md">
# AG Grid Enterprise Components

A comprehensive collection of reusable grid components built with AG Grid Enterprise, designed for modern React applications with TypeScript support. This module provides a complete data grid solution with advanced features for data management, layout persistence, and user interaction.

## 🎯 Overview

This grid system provides a complete data grid solution with the following features:

### Core Features

- **Multi-draft row management** for batch operations
- **Real-time data synchronization** with API endpoints
- **Grid state persistence** for user preferences
- **Advanced filtering and sorting** capabilities
- **Error handling** with detailed user feedback
- **Responsive design** that works on all devices

### Advanced Features

- **Layout management** with user-specific saved layouts
- **Undo/Redo functionality** with history tracking
- **Visual change tracking** with row and cell styling
- **Custom toolbar** with CRUD operations
- **Sidebar panels** for columns, filters, and layouts
- **Status bar** with row counts and layout information

## 🏗️ Architecture

The grid system follows a **modular architecture** with clear separation of concerns:

### Core Components

| Component     | Purpose                     | Lines | Features                        |
| ------------- | --------------------------- | ----- | ------------------------------- |
| `BaseGrid`    | Main grid orchestrator      | ~432  | Complete grid with all features |
| `GridToolbar` | Action buttons and controls | ~108  | CRUD operations, undo/redo      |
| `ErrorDialog` | Error display and handling  | ~79   | User-friendly error messages    |
| `GridConfig`  | Grid configuration          | ~214  | Status bar, sidebar, defaults   |

### Custom Hooks

| Hook                       | Responsibility                   | Features                                                 |
| -------------------------- | -------------------------------- | -------------------------------------------------------- |
| `useRowManagement`         | Row operations & change tracking | Add, delete, duplicate, save, undo/redo, visual feedback |
| `useGridState`             | State management & persistence   | Data loading, grid API, state restoration                |
| `useUndoRedo`              | History management               | Undo/redo with Immer, history limits                     |
| `useErrorHandler`          | Error management                 | Error display, user feedback, error recovery             |
| `useDataFetcher`           | API communication                | Data fetching, caching, error handling                   |
| `useUnsavedChangesWarning` | Navigation warnings              | Browser warnings, refresh confirmations                  |
| `useLayoutManager`         | Layout operations                | Save/load layouts, layout changes                        |

### Layout Management

| Component           | Purpose               | Features                       |
| ------------------- | --------------------- | ------------------------------ |
| `LayoutsToolPanel`  | Layout management UI  | Create, delete, select layouts |
| `LayoutStatusPanel` | Layout status display | Current layout, save button    |
| `useLayoutManager`  | Layout operations     | Save, load, change layouts     |

### Utility Functions

| Module                      | Purpose                           |
| --------------------------- | --------------------------------- |
| `gridComponentRegistration` | AG Grid component registration    |
| `gridStateUtils`            | Grid state utilities and examples |

## 🚀 Quick Start

### Basic Usage

```tsx
import BaseGrid from "../common/grid/BaseGrid";
import type { ColDef } from "ag-grid-enterprise";

interface User {
	id: string;
	name: string;
	email: string;
	role: string;
}

const UserGrid = () => {
	const colDefs: ColDef<User>[] = [
		{ field: "name", headerName: "Name", editable: true },
		{ field: "email", headerName: "Email", editable: true },
		{ field: "role", headerName: "Role", editable: true },
	];

	return (
		<BaseGrid<User>
			gridId="users-grid"
			endpoint="/api/users"
			colDefs={colDefs}
			primaryKey="id"
		/>
	);
};
```

### Advanced Usage with Custom Configuration

```tsx
import BaseGrid from "../common/grid/BaseGrid";
import type { ColDef } from "ag-grid-enterprise";

interface Project {
	id: string;
	name: string;
	status: "active" | "completed" | "pending";
	budget: number;
	startDate: Date;
}

const ProjectGrid = () => {
	const colDefs: ColDef<Project>[] = [
		{ field: "name", headerName: "Project Name", editable: true },
		{
			field: "status",
			headerName: "Status",
			editable: true,
			cellEditor: "agSelectCellEditor",
			cellEditorParams: {
				values: ["active", "completed", "pending"],
			},
		},
		{
			field: "budget",
			headerName: "Budget",
			editable: true,
			valueFormatter: (params) => `$${params.value?.toLocaleString()}`,
		},
		{
			field: "startDate",
			headerName: "Start Date",
			editable: true,
			valueFormatter: (params) => params.value?.toLocaleDateString(),
		},
	];

	const defaultColDef: Partial<ColDef<Project>> = {
		sortable: true,
		filter: true,
		resizable: true,
	};

	return (
		<BaseGrid<Project>
			gridId="projects-grid"
			endpoint="/api/projects"
			colDefs={colDefs}
			defaultColDef={defaultColDef}
			primaryKey="id"
			sideBarEnabled={true}
		/>
	);
};
```

## 📁 File Structure

```
grid/
├── BaseGrid.tsx                    # Main grid component (orchestrator)
├── GridConfig.tsx                  # Grid configuration functions
├── ag-grid-theme.css              # AG Grid styles
├── components/                     # Reusable UI components
│   ├── ErrorDialog.tsx            # Error display component
│   ├── ErrorDetails.tsx           # Error details sub-component
│   ├── GridToolbar.tsx            # Toolbar component
│   └── GridToolbarButton.tsx      # Individual toolbar button
├── hooks/                         # Custom logic hooks
│   ├── useRowManagement.ts        # Row operations & change tracking
│   ├── useGridState.ts           # Grid state management
│   ├── useUndoRedo.ts            # Undo/redo functionality
│   ├── useErrorHandler.ts        # Error handling logic
│   ├── useDataFetcher.ts         # Data fetching logic
│   ├── useRowOperations.ts       # Row operations logic
│   ├── useChangeTracker.ts       # Change tracking logic
│   └── useUnsavedChangesWarning.ts # Navigation warnings
├── layouts/                       # Layout management
│   ├── LayoutsToolPanel.tsx      # Layout management UI
│   ├── LayoutStatusPanel.tsx     # Layout status display
│   ├── LayoutContext.tsx         # React context for layouts
│   ├── useLayoutManager.ts       # Layout operations hook
│   ├── types.ts                  # Layout type definitions
│   └── index.ts                  # Layout exports
├── utils/                         # Utility functions
│   ├── gridComponentRegistration.ts # AG Grid component registration
│   └── gridStateUtils.ts         # Grid state utilities
└── README.md                      # This documentation
```

## 🔧 Component API

### BaseGrid Props

| Prop             | Type                 | Required | Description                                  |
| ---------------- | -------------------- | -------- | -------------------------------------------- |
| `gridId`         | `string`             | Yes      | Unique identifier for grid state persistence |
| `endpoint`       | `string`             | No       | API endpoint for data operations             |
| `colDefs`        | `ColDef<T>[]`        | Yes      | Column definitions for the grid              |
| `defaultColDef`  | `Partial<ColDef<T>>` | No       | Default column configuration                 |
| `primaryKey`     | `string`             | Yes      | Primary key field for row identification     |
| `sideBarEnabled` | `boolean`            | No       | Enable grid sidebar (default: true)          |

### Grid Features

#### Row Management

- **Multi-draft support**: Create multiple draft rows simultaneously
- **Batch operations**: Save all changes at once
- **Change tracking**: Track unsaved changes with visual feedback
- **Undo/Redo**: Full history management with keyboard shortcuts

#### Visual Feedback

- **New rows**: Green background with left border
- **Modified rows**: Orange background with left border
- **Deleted rows**: Red background with opacity
- **Failed rows**: Red background for save errors

#### Layout Management

- **User-specific layouts**: Save and load custom grid configurations
- **Layout persistence**: Backend storage for layout data
- **Layout switching**: Quick switching between saved layouts
- **Default layouts**: Automatic default layout creation

#### State Persistence

- **Grid state**: Column order, width, visibility
- **Filter state**: Applied filters
- **Sort state**: Applied sorting
- **User preferences**: Per-user settings

#### Error Handling

- **Detailed error messages**: User-friendly error display
- **Error recovery**: Automatic retry mechanisms
- **Validation feedback**: Real-time validation errors
- **Error details**: Expandable error information

## 🎨 Customization

### Custom Cell Editors

```tsx
import CustomTextEditor from "./components/CustomTextEditor";

const colDefs: ColDef<User>[] = [
	{
		field: "name",
		headerName: "Name",
		editable: true,
		cellEditor: CustomTextEditor,
		cellEditorParams: {
			maxLength: 50,
			placeholder: "Enter name...",
		},
	},
];
```

### Custom Toolbar Actions

```tsx
import GridToolbar from "./components/GridToolbar";

const CustomToolbar = () => (
	<GridToolbar
		onAddRow={handleAddRow}
		onDeleteRows={handleDeleteRows}
		onRefresh={handleRefresh}
		onExport={handleExport}
		hasUnsavedChanges={hasUnsavedChanges}
		onUndo={undo}
		onRedo={redo}
		canUndo={canUndo}
		canRedo={canRedo}
	/>
);
```

### Custom Error Handling

```tsx
import ErrorDialog from "./components/ErrorDialog";

const CustomErrorDialog = () => (
	<ErrorDialog
		error={error}
		showDialog={showDialog}
		onClose={handleClose}
		onRetry={handleRetry}
	/>
);
```

## 🔄 Data Flow

### 1. Data Fetching

```
API Request → useDataFetcher → Grid State → UI Update
```

### 2. Row Management

```
User Action → useRowManagement → State Update → UI Refresh
```

### 3. Change Tracking

```
Cell Edit → markDirty → Tracking Sets → Visual Feedback
```

### 4. Save Operations

```
Save Request → Batch API Call → Server Response → State Update
```

### 5. Layout Management

```
Layout Change → useLayoutManager → Grid State → UI Update
```

## 🧪 Testing

### Component Testing

```tsx
import { render, screen } from "@testing-library/react";
import BaseGrid from "./BaseGrid";

describe("BaseGrid", () => {
	it("renders grid with data", () => {
		const colDefs = [{ field: "name", headerName: "Name" }];
		const data = [{ id: "1", name: "Test User" }];

		render(<BaseGrid gridId="test-grid" colDefs={colDefs} primaryKey="id" />);

		expect(screen.getByText("Test User")).toBeInTheDocument();
	});
});
```

### Hook Testing

```tsx
import { renderHook } from "@testing-library/react";
import { useGridState } from "./hooks/useGridState";

describe("useGridState", () => {
	it("manages grid state correctly", () => {
		const { result } = renderHook(() =>
			useGridState({ gridId: "test", fetchData: jest.fn() })
		);

		expect(result.current.rowData).toEqual([]);
		expect(result.current.isLoading).toBe(false);
	});
});
```

## 🚀 Performance Optimization

### 1. Memoization

- **Column definitions**: Memoize with `useMemo`
- **Grid configuration**: Cache configuration objects
- **Event handlers**: Use `useCallback` for handlers

### 2. Data Virtualization

- **Large datasets**: AG Grid handles virtualization automatically
- **Row rendering**: Only visible rows are rendered
- **Column rendering**: Only visible columns are rendered

### 3. State Management

- **Selective updates**: Only update changed data
- **Batch operations**: Group multiple operations
- **Debounced updates**: Prevent excessive re-renders

## 🔧 Configuration

### Grid Configuration

```tsx
import {
	createStatusBar,
	createSideBar,
	createRowSelection,
} from "./GridConfig";

const statusBar = createStatusBar();
const sideBar = createSideBar(true);
const rowSelection = createRowSelection();
```

### Column Configuration

```tsx
import { createDefaultColDef } from "./GridConfig";

const defaultColDef = createDefaultColDef({
	sortable: true,
	filter: true,
	resizable: true,
	editable: true,
});
```

## 🐛 Troubleshooting

### Common Issues

#### 1. Grid Not Rendering

- Check if `colDefs` are properly defined
- Verify `primaryKey` is set correctly
- Ensure data is in the expected format

#### 2. Draft Rows Not Saving

- Verify API endpoint is correct
- Check network connectivity
- Review server-side validation

#### 3. State Not Persisting

- Check browser storage permissions
- Verify `gridId` is unique
- Review localStorage implementation

#### 4. Performance Issues

- Implement data virtualization for large datasets
- Use memoization for expensive calculations
- Optimize column definitions

### Debug Mode

Enable debug logging:

```tsx
const BaseGrid = <T,>({ debug = false, ...props }: BaseGridProps<T>) => {
	if (debug) {
		console.log("Grid props:", props);
		console.log("Grid state:", gridState);
	}
	// ... rest of component
};
```

## 📚 Examples

### Complete Example

```tsx
import React, { useMemo } from "react";
import BaseGrid from "../common/grid/BaseGrid";
import type { ColDef } from "ag-grid-enterprise";

interface Product {
	id: string;
	name: string;
	category: string;
	price: number;
	inStock: boolean;
}

const ProductGrid = () => {
	const colDefs = useMemo<ColDef<Product>[]>(
		() => [
			{ field: "name", headerName: "Product Name", editable: true },
			{ field: "category", headerName: "Category", editable: true },
			{
				field: "price",
				headerName: "Price",
				editable: true,
				valueFormatter: (params) => `$${params.value?.toFixed(2)}`,
			},
			{
				field: "inStock",
				headerName: "In Stock",
				editable: true,
				cellRenderer: "agCheckboxCellRenderer",
			},
		],
		[]
	);

	const defaultColDef = useMemo(
		() => ({
			sortable: true,
			filter: true,
			resizable: true,
		}),
		[]
	);

	return (
		<div className="h-full">
			<BaseGrid<Product>
				gridId="products-grid"
				endpoint="/api/products"
				colDefs={colDefs}
				defaultColDef={defaultColDef}
				primaryKey="id"
				sideBarEnabled={true}
			/>
		</div>
	);
};

export default ProductGrid;
```

## 🔄 Migration Guide

### From Previous Versions

1. **Update imports**: Use new modular structure
2. **Update props**: Follow new API design
3. **Test functionality**: Verify all features work
4. **Update documentation**: Review component usage

### Breaking Changes

- **Grid state API**: Updated persistence mechanism
- **Error handling**: New error dialog component
- **Draft row management**: Enhanced batch operations

## 🤝 Contributing

### Development Guidelines

1. **Follow TypeScript**: Use strict typing
2. **Write tests**: Add tests for new features
3. **Update docs**: Keep documentation current
4. **Follow patterns**: Use existing component patterns

### Adding New Features

1. **Create hook**: Add logic to appropriate hook
2. **Update component**: Modify component as needed
3. **Add tests**: Write comprehensive tests
4. **Update docs**: Document new functionality

---

**Built with AG Grid Enterprise and React 18**
</file>

<file path="utils/gridComponentRegistration.ts">
import LayoutsToolPanel from "../layouts/LayoutsToolPanel";
import LayoutStatusPanel from "../layouts/LayoutStatusPanel";

/**
 * Registers custom AG Grid components globally
 *
 * This function registers our custom React components with AG Grid's
 * component system by attaching them to the global window object.
 * This allows AG Grid to find and instantiate our custom components
 * when they are referenced in the grid configuration.
 *
 * The registration happens only on the client side (browser environment)
 * to avoid SSR-related issues. This is necessary because AG Grid
 * looks for components on the global window object during initialization.
 *
 * Components registered:
 * - agLayoutsToolPanel: Custom tool panel for layout management
 * - agLayoutStatusPanel: Custom status panel showing current layout
 */
export const registerGridComponents = () => {
	if (typeof window !== "undefined") {
		// Register custom tool panel for layout management
		(window as any).agLayoutsToolPanel = LayoutsToolPanel;
		// Register custom status panel for layout information
		(window as any).agLayoutStatusPanel = LayoutStatusPanel;
	}
};

/**
 * Returns the custom components object for AG Grid
 *
 * This function provides the components object that can be passed
 * directly to the AgGridReact component's `components` prop.
 * It maps component names to their React component implementations.
 *
 * This approach ensures that AG Grid can properly instantiate and
 * manage our custom components within the grid's component system.
 * The components object is used by AG Grid to resolve component
 * references in the grid configuration.
 *
 * @returns Object mapping component names to React components
 */
export const getGridComponents = () => ({
	agLayoutsToolPanel: LayoutsToolPanel,
	agLayoutStatusPanel: LayoutStatusPanel,
});
</file>

</files>
